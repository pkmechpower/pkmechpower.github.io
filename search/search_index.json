{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PK MechPower Codebase","text":"<p>Warning</p> <p>TODO</p>"},{"location":"common/can/can/","title":"CAN","text":"<p>Warning</p> <p>TODO</p>"},{"location":"common/can/message_definition_guide/","title":"Message Definition &amp; Generation Guide","text":"<p>Warning</p> <p>Outdated</p> <p>This guide explains how to add a new message to the system, including CAN and UART configuration, and generate the necessary C++ and Python code using the generator tool.</p>"},{"location":"common/can/message_definition_guide/#file-locations","title":"File Locations","text":"Purpose Path / Folder Message definitions (YAML) <code>messages.yaml</code> Generator script <code>generator.py</code> Jinja2 templates <code>templates/</code> Generated output <code>gen/</code>"},{"location":"common/can/message_definition_guide/#adding-a-new-message","title":"Adding a New Message","text":""},{"location":"common/can/message_definition_guide/#1-edit-messagesyaml","title":"1. Edit <code>messages.yaml</code>","text":"<p>Every message belongs under the top\u2011level <code>messages:</code> list.  Provide at least the following keys:</p> Key Required? Description <code>name</code> \u2714 Descriptive class\u2011style name, e.g. <code>Motor_Temperature</code> <code>id</code> \u2714 Numeric Active::Message ID (0\u2013255, unique) <code>source</code> \u2714 Node that transmits the message (must exist in <code>nodes:</code>) <code>receivers</code> \u2714 (list) Nodes that receive the message <code>payload</code> optional Ordered list of field definitions (see below) <code>transports</code> \u2714 Transport\u2011specific settings (CAN / UART) <pre><code>- name: Motor_Temperature\n  id: 200\n  source: MOTOR_DRIVER_LEFT\n  receivers: [MCS_MAIN, LOGGER_PC]\n  description: Temperature of motor driver IGBT\n  payload:\n    - { name: igbt_temp_celsius, type: float, uart_type: float }\n  transports:\n    can:\n      dlc: 3\n      layout:\n        - { byte: 1, field: igbt_temp_celsius }\n    uart: {}\n</code></pre>"},{"location":"common/can/message_definition_guide/#2-field-reference","title":"2. Field Reference","text":"Field key Meaning <code>name</code> C++ tuple field name <code>type</code> Raw CAN storage type (<code>uint8</code>, <code>uint16</code>, <code>float</code>, \u2026) <code>uart_type</code> Type when sent over UART (defaults to <code>type</code>) <code>encode</code> C++ function to pack raw value into CAN byte(s) <code>decode</code> C++ function to unpack raw value from CAN byte(s) <code>&lt;&lt;: *alias</code> Merge properties from a common anchor (see <code>common:</code> section)"},{"location":"common/can/message_definition_guide/#3-transport-details","title":"3. Transport Details","text":""},{"location":"common/can/message_definition_guide/#can-settings","title":"CAN settings","text":"<pre><code>transports:\n  can:\n    dlc: 5                     # data\u2011length code (1\u20118 bytes)\n    layout:\n      - { byte: 1, field: brake_pct }\n      - { byte: 2, field: accel_pct }\n      - { byte: 3, field: steering, slice: hi }\n      - { byte: 4, field: steering, slice: lo }\n</code></pre> <ul> <li><code>layout.byte</code> is 1\u2011based for readability.</li> <li>Use <code>slice: hi/lo</code> to split 16\u2011bit fields.</li> </ul> <p>Disable CAN for a message:</p> <pre><code>transports:\n  can: { disabled: true }\n</code></pre>"},{"location":"common/can/message_definition_guide/#uart-settings","title":"UART settings","text":"<pre><code>transports:\n  uart: {}      # present \u21d2 message is sent over UART\n</code></pre> <p>If <code>uart</code> is omitted the message is not transmitted over UART.</p>"},{"location":"common/can/message_definition_guide/#generator-usage","title":"Generator Usage","text":"<pre><code>python generator.py\n</code></pre> <p>The script will:</p> <ol> <li>Parse <code>messages.yaml</code></li> <li>Compute derived data (CAN IDs, C++ types, decode expressions)</li> <li>Render templates into <code>gen/</code></li> <li>Optionally run <code>clang-format</code> on C/C++ output</li> </ol> Generated file Contents <code>active_messages.h</code> <code>using Foo_Msg = Active::Message&lt;\u2026&gt;</code> <code>can_traits.h</code> <code>CAN_Message_Traits&lt;&gt;</code> encode/decode impl <code>message_forwarder.h</code> Switch logic for ETL\u21c4CAN forwarding <code>gen/uart_debug.py</code> Python decoder for UART stream"},{"location":"common/can/message_definition_guide/#workflow-recap","title":"Workflow Recap","text":"<ol> <li>Add / edit messages in <code>messages.yaml</code>.</li> <li>Run <code>python generator.py</code>.</li> <li>Inspect <code>gen/</code> output (code\u2011review encouraged).</li> <li>Build firmware; include generated headers.</li> <li>Use <code>python gen/uart_debug.py COM5 115200</code> to inspect UART data.</li> </ol>"},{"location":"common/can/message_definition_guide/#troubleshooting","title":"Troubleshooting","text":"Symptom Likely Cause &amp; Fix <code>TemplateSyntaxError</code> with <code>for</code> Avoid list comprehensions inside <code>{{ \u2026 }}</code> blocks Unknown message ID in UART debug Message lacks <code>transports: uart</code> section CAN decode returns zeros Field missing from <code>layout</code> or bad byte indices Duplicate IDs / collisions Keep <code>id</code> unique; generator will warn in future"},{"location":"library/torque_map/","title":"Torque Map","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/architecture/","title":"MCS_Back - Architecture","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_front/architecture/","title":"MCS_Front - Architecture","text":""},{"location":"mcs_front/architecture/#high-level-system-design","title":"High Level System Design","text":""},{"location":"mcs_front/architecture/#high-level-data-flow","title":"High Level Data Flow","text":""},{"location":"mcs_front/architecture/#first-tier-tasks","title":"First tier tasks","text":""},{"location":"mcs_front/architecture/#application-tasks","title":"Application tasks","text":""},{"location":"mcs_front/architecture/#synchronization-and-data-flow","title":"Synchronization and data flow","text":""},{"location":"mcs_front/architecture/#tasks","title":"Tasks","text":""},{"location":"mcs_front/architecture/#process-inputs","title":"Process Inputs","text":"<p>Process Inputs task takes care of processing sensors measurements and digital input states to a meaningful data or events, that are then used by the Application. Processed analog and speed measurements are stored in the Process data store. This structure is protected by a mutex. This mutex can be taken either by this task or Application. Application should be informed when new data has been written to this structure. This information should be passed via a queue. Events that are generated based on button (digital input) states, are also passed to Application via a queue.</p>"},{"location":"mcs_front/architecture/#analog-sensors","title":"Analog sensors","text":"<p>Each time the DMA finishes full ADC reading cycle, it should enqueue new data to the Process Inputs queue.</p>"},{"location":"mcs_front/architecture/#pwm-signals","title":"PWM signals","text":"<p>Wheel speed sensors are the only sources of PWM signals. Based on the rising and falling edges of these signals, the actual wheel speed should be calculated inside the interrupt routine and then enqueued to Process Inputs. Process Inputs should monitor when he received the last speed measurement. If there's no new update of speed for some precalculated, realistic time, the value of speed measurement stored in Process data store should be set to 0.</p>"},{"location":"mcs_front/architecture/#process-buttons","title":"Process Buttons","text":"<p>Digital inputs should be periodically read by the Process Buttons. This task should implement software debouncing, so the button needs to be pushed or released continuously for a predefined period of time for the transition to be detected. If the transition is detected, an event about such transition should be enqueued to Application. For some buttons, e.g. R2D there should be an additional long press detection implemented, so that if the button is pressed for a long (predefined) period of time, additional event is enqueued for the Application informing about it. It will be needed so to prevent driver from mistakenly pushing the button and leaving the R2D mode during the race.</p>"},{"location":"mcs_front/architecture/#network-manager","title":"Network Manager","text":"<p>Network Manager is common between different MechPower created boards. Further information about this task can be found on CAN page.</p>"},{"location":"mcs_front/architecture/#application","title":"Application","text":"<p>Application Task performs mainly two functions. It runs the state machine and analyzes faults coming from the Network Manager.</p>"},{"location":"mcs_front/architecture/#handling-faults","title":"Handling faults","text":"<p>Statuses of different car elements are interpreted by the Fault Interpreter block indicated on the diagram. It stores the current state (faulty or fault free) of: motors, motor drivers, insulation monitoring device, accumulator management system and other internal signals. If any of these states change, a corresponding flag is raised and sent to the Indicators Control task.</p> <p>Also, when there are any faults present, they are sorted by their severity. The most severe one is sent to the state machine, which can then prevent driver from entering the TS activated or R2D modes. It's also sent to the UI, to be presented for the driver.</p>"},{"location":"mcs_front/architecture/#ui","title":"UI","text":"<p>Warning</p> <p>TODO</p> <p>UI task should interpret messages enqueued to it. These message can either change screens or data displayed on these screens. It should act as a gateway to the TouchGFX generated code/task.</p>"},{"location":"mcs_front/architecture/#indicators-control","title":"Indicators Control","text":"<p>Indicators Control Task continuously reads the queue, listening for fault events. These events can either set or clear faults, which are then displayed to the driver via LED indicators.</p>"},{"location":"mcs_front/state_machine/","title":"Display State Machine","text":"<p>Warning</p> <p>Outdated</p> <p>Display state machine (SM) consists of one main SM and few inner ones.</p>"},{"location":"mcs_front/state_machine/#main-sm","title":"Main SM","text":"<p>Main SM states are:</p> <ul> <li>Initialization,</li> <li>Idle,</li> <li>R2D.</li> </ul> <p>Initialization is a state during which the calibration process happens.</p> <p>Idle is a state, when device awaits inputs from the driver. Driver can then change settings of the car, and try to grant permissions for TS activation.</p> <p>R2D is the Ready2Drive state. Driver can't change any previously set settings of the car. The car is ready for a race.</p>"},{"location":"mcs_front/state_machine/#calibration","title":"Calibration","text":""},{"location":"mcs_front/state_machine/#settings","title":"Settings","text":""},{"location":"mcs_front/state_machine/#r2d","title":"R2D","text":"<pre>b7ac538ecf0fdce357cbc96b7755d7a5514815ad2b758a32526f0b7e3048e29ad35c2b2268a6958e79ccd0768d066b26ecb2c12d0319aa3a81a53f6f0b2dde55</pre><pre>b141fddeed2532dabc85d14982f7e56a64e2af75bcb005d946f20472aab6724e88fb0a700b7066aec296a4a492a47b64a0c4a65a4f0b05269f651a333d77cc34</pre>"}]}