{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PK MechPower Codebase","text":"<p>Warning</p> <p>TODO</p>"},{"location":"common/message_forwarders/","title":"Message Forwarders","text":"<p>Warning</p> <p>TODO</p>"},{"location":"common/network_manager/","title":"Network Manager","text":"<p>Network Manager is a task responsible for handling communication to and from the Application to external interfaces like CAN.</p>"},{"location":"common/network_manager/#task","title":"Task","text":"<p>Task expect a list of arguments, which currently look like the code listing below.</p> <pre><code>struct Network_Manager_Task_Arguments\n{\n    Node_Defines_Interface *node;\n    Firmware::CAN_Handler_Interface *can_1;\n    Firmware::CAN_Handler_Interface *can_2;\n    MessageBufferHandle_t rx_buffer;\n    MessageBufferHandle_t tx_buffer;\n};\n</code></pre> <p>The last two: <code>message_buffer_receive</code> and <code>message_buffer_send</code> are wrappers for FreeRTOS macros. They are present, so the task can be decoupled from the actual FreeRTOS macros, so it can be unit-tested and exist as an enclosed element.</p> <p>The <code>node</code> pointer is necessary for the forwarding algorithms, used for translating messages between different, communication interface specific frames and messages used in the software.</p> <p>Network Manager implementation consists of two actions described below.</p>"},{"location":"common/network_manager/#processing-messages-incoming-from-external-communication-interfaces-to-software","title":"Processing messages incoming from external communication interfaces to software","text":"<pre><code>while (network_manger.process_incoming_message(message_buffer, &amp;message_size))\n{\n    if (xMessageBufferSend(params-&gt;tx_buffer, message_buffer, message_size, 0) != message_size)\n    {\n        // Note: Call to message_buffer_send timed-out before there was enough space in the buffer for the data\n        // to be written\n        ++g_network_manager_overflow_counter;\n    }\n}\n</code></pre> <p>Here, the Network Manager class checks each communication interface attached to it for received messages. If one is received and successfully retrieved (translated to software friendly and protocol independent message) it is put to the TX message buffer. Later it can be read from this buffer by the Application.</p>"},{"location":"common/network_manager/#processing-messages-outgoing-from-software-to-external-communication-interfaces","title":"Processing messages outgoing from software to external communication interfaces","text":"<pre><code>message_size = xMessageBufferReceive(params-&gt;rx_buffer, (void *)message_buffer, sizeof(message_buffer), 0);\nif (message_size &gt; 0)\n{\n    network_manger.process_outgoing_message(message_buffer, message_size);\n}\nile (message_size &gt; 0);\n</code></pre> <p>Here, the RX buffer is checked for any messages that software want's to transmit to the outside world. If any message is buffered it is put to the Network Manager class to be processed. Successful processing of such message result in it being transmitted or enqueued to be transmitted by the corresponding communication interface (interface mapped to support this specific message for transmission).</p>"},{"location":"common/network_manager/#class","title":"Class","text":"<p>Network Manager heavily utilizes message forwarders.</p> <p>As it is directly used by the Network Manager task it implements the actual functionalities of processing messages, as described below.</p>"},{"location":"common/network_manager/#processing-messages-incoming-from-external-communication-interfaces","title":"Processing messages incoming from external communication interfaces","text":"<pre><code>bool process_incoming_message(uint8_t *message, uint32_t *size)\n{\n    bool retval = false;\n    for (auto &amp;handler : m_can_handlers)\n    {\n        Firmware::CAN_Frame frame{};\n        if (handler-&gt;pop_rx_frame(frame))\n        {\n            return m_can_to_buffered_forwarder.try_forwarding(frame, message, size);\n        }\n    }\n    return retval;\n};\n</code></pre> <p>Here, all <code>m_[x]_handlers</code> handlers are checked if they contain any yet unprocessed messages. If so, the respective (for communication interface) forwarder is used to try to retrieve this incoming message. If successful, the method returns <code>true</code> and received message is stored in the <code>message</code> buffer of <code>size</code> size.</p>"},{"location":"common/network_manager/#processing-messages-outgoing-from-software","title":"Processing messages outgoing from software","text":"<pre><code>bool process_outgoing_message(const uint8_t *message, uint16_t size)\n{\n    bool retval = false;\n    retval = m_can_forwarder.try_forwarding(message, size);\n    return retval;\n};\n</code></pre> <p>Here, all <code>m_[x]_handlers</code> handlers are checked if they support the message that the software want to transmit. If so, it is translated by the corresponding forwarder to a protocol specific frame and either imidiatelly transmitted (if bus/hardware buffer is free) or enqueued for such transmission.</p>"},{"location":"common/network_manager/#debugging","title":"Debugging","text":"<p>There is a global variable <code>g_network_manager_overflow_counter</code> which indicates how many times calls to <code>message_buffer_send(...)</code> timed-out before there was enough space in the TX buffer for the data to be written. It is expected for this value to be always equal to 0.</p>"},{"location":"common/can/can/","title":"CAN","text":"<p>Warning</p> <p>TODO</p>"},{"location":"common/can/can/#testing","title":"Testing","text":"<p>For testing purposes, one can set CAN peripheral into Loopback mode. To do it, first select said mode as Operating Mode, see picture below.</p> <p></p> <p>Then, set GPIO Pull-up/Pull-down of RX pin of the corresponding CAN peripheral to the Pull-up option.</p> <p></p>"},{"location":"common/can/message_definition_guide/","title":"Macro Syntax Error","text":"<p>File: <code>common/can/message_definition_guide.md</code></p> <p>Line 139 in Markdown file: unexpected char '\u2026' at 4418 <pre><code>| `TemplateSyntaxError` with `for`          | Avoid list comprehensions inside `{{ \u2026 }}` blocks |\n</code></pre></p>"},{"location":"infrastructure/github_actions/","title":"GitHub Actions Workflows Documentation","text":"<p>This document describes the CI/CD workflows configured for the PK MechPower project.</p>"},{"location":"infrastructure/github_actions/#workflow-overview","title":"Workflow Overview","text":"<p>The project has four GitHub Actions workflows that handle continuous integration, testing, documentation deployment, and manual builds.</p>"},{"location":"infrastructure/github_actions/#1-continuous-integration-mp_ci_windowsyaml","title":"1. Continuous Integration (<code>mp_ci_windows.yaml</code>)","text":"<p>Trigger: Automatically runs on:</p> <ul> <li>Push to <code>master</code> branch</li> <li>Pull requests to <code>master</code> branch</li> </ul> <p>Environment: Windows Server (latest)</p> <p>Build Type: Release</p>"},{"location":"infrastructure/github_actions/#jobs","title":"Jobs","text":""},{"location":"infrastructure/github_actions/#unit-tests-build-unit_tests","title":"Unit Tests Build (<code>unit_tests</code>)","text":"<ul> <li>Checks out repository with minimal submodules</li> <li>Initializes required submodules: <code>etl</code>, <code>gtest</code></li> <li>Configures CMake with:</li> <li>Ninja generator</li> <li>Clang compiler (C and C++)</li> <li>C++23 standard</li> <li>Builds <code>UnitTests</code> target</li> <li>Uploads <code>UnitTests.exe</code> as artifact</li> </ul>"},{"location":"infrastructure/github_actions/#integration-tests-build-integration_tests","title":"Integration Tests Build (<code>integration_tests</code>)","text":"<ul> <li>Checks out repository with minimal submodules</li> <li>Initializes required submodules: <code>etl</code>, <code>active_lib</code>, <code>gtest</code>, <code>freertos_kernel</code>, <code>Percepio_TraceRecorder</code></li> <li>Configures CMake with:</li> <li>FreeRTOS port: MINGW</li> <li>Ninja generator</li> <li>Clang compiler</li> <li>C++23 standard</li> <li>Builds <code>IntegrationTests</code> target</li> <li>Uploads <code>IntegrationTests.exe</code> as artifact</li> </ul>"},{"location":"infrastructure/github_actions/#mcs-front-build-mcs_front","title":"MCS Front Build (<code>mcs_front</code>)","text":"<ul> <li>Checks out repository with minimal submodules</li> <li>Initializes required submodules: <code>etl</code>, <code>active_lib</code>, <code>stm32_f7xx</code></li> <li>Downloads and caches ARM GCC Toolchain (xPack v12.3.1)</li> <li>Configures CMake for ARM Cortex-M7 cross-compilation</li> <li>Builds <code>MCS_Front</code> target</li> </ul>"},{"location":"infrastructure/github_actions/#mcs-back-build-mcs_back","title":"MCS Back Build (<code>mcs_back</code>)","text":"<ul> <li>Checks out repository with minimal submodules</li> <li>Initializes required submodules: <code>etl</code>, <code>active_lib</code>, <code>stm32_h7xx</code></li> <li>Downloads and caches ARM GCC Toolchain (xPack v12.3.1)</li> <li>Configures CMake for ARM Cortex-M7 (dual-core STM32H7) cross-compilation</li> <li>Builds <code>MCS_Back</code> target (both CM7 and CM4 cores)</li> </ul>"},{"location":"infrastructure/github_actions/#unit-tests-run-unit_tests_run","title":"Unit Tests Run (<code>unit_tests_run</code>)","text":"<ul> <li>Depends on: <code>unit_tests</code></li> <li>Downloads <code>UnitTests.exe</code> artifact</li> <li>Executes unit tests with Google Test</li> <li>Generates XML test results</li> </ul>"},{"location":"infrastructure/github_actions/#integration-tests-run-integration_tests_run","title":"Integration Tests Run (<code>integration_tests_run</code>)","text":"<ul> <li>Depends on: <code>integration_tests</code></li> <li>Downloads <code>IntegrationTests.exe</code> artifact</li> <li>Executes integration tests with Google Test</li> <li>Generates XML test results</li> </ul>"},{"location":"infrastructure/github_actions/#2-manual-unit-tests-mp_manual_unit_testsyaml","title":"2. Manual Unit Tests (<code>mp_manual_unit_tests.yaml</code>)","text":"<p>Trigger: Manual dispatch with configurable branch selection</p> <p>Default Branch: <code>master</code></p> <p>Environment: Windows Server (latest)</p> <p>Build Type: Release</p>"},{"location":"infrastructure/github_actions/#input-parameters","title":"Input Parameters","text":"<ul> <li><code>target_branch</code>: Branch to build and test (required)</li> </ul>"},{"location":"infrastructure/github_actions/#jobs_1","title":"Jobs","text":""},{"location":"infrastructure/github_actions/#unit-tests-build-unit_tests_1","title":"Unit Tests Build (<code>unit_tests</code>)","text":"<ul> <li>Checks out specified branch</li> <li>Initializes required submodules: <code>etl</code>, <code>gtest</code></li> <li>Configures and builds unit tests</li> <li>Uploads <code>UnitTests.exe</code> as artifact</li> </ul>"},{"location":"infrastructure/github_actions/#unit-tests-run-unit_tests_run_1","title":"Unit Tests Run (<code>unit_tests_run</code>)","text":"<ul> <li>Depends on: <code>unit_tests</code></li> <li>Downloads and executes unit tests</li> <li>Generates XML test results</li> </ul>"},{"location":"infrastructure/github_actions/#3-manual-integration-tests-mp_manual_integration_testsyaml","title":"3. Manual Integration Tests (<code>mp_manual_integration_tests.yaml</code>)","text":"<p>Trigger: Manual dispatch with configurable branch selection</p> <p>Default Branch: <code>master</code></p> <p>Environment: Windows Server (latest)</p> <p>Build Type: Release</p>"},{"location":"infrastructure/github_actions/#input-parameters_1","title":"Input Parameters","text":"<ul> <li><code>target_branch</code>: Branch to build and test (required)</li> </ul>"},{"location":"infrastructure/github_actions/#jobs_2","title":"Jobs","text":""},{"location":"infrastructure/github_actions/#integration-tests-build-integration_tests_1","title":"Integration Tests Build (<code>integration_tests</code>)","text":"<ul> <li>Checks out specified branch</li> <li>Initializes required submodules: <code>etl</code>, <code>active_lib</code>, <code>gtest</code>, <code>freertos_kernel</code>, <code>Percepio_TraceRecorder</code></li> <li>Configures and builds integration tests with FreeRTOS MINGW port</li> <li>Uploads <code>IntegrationTests.exe</code> as artifact</li> </ul>"},{"location":"infrastructure/github_actions/#integration-tests-run-integration_tests_run_1","title":"Integration Tests Run (<code>integration_tests_run</code>)","text":"<ul> <li>Depends on: <code>integration_tests</code></li> <li>Downloads and executes integration tests</li> <li>Generates XML test results</li> </ul>"},{"location":"infrastructure/github_actions/#4-documentation-deployment-deploy_mk_docsyaml","title":"4. Documentation Deployment (<code>deploy_mk_docs.yaml</code>)","text":"<p>Trigger: Automatically runs on push to <code>master</code> branch</p> <p>Environment: Ubuntu (latest)</p> <p>Python Version: 3.11</p>"},{"location":"infrastructure/github_actions/#jobs_3","title":"Jobs","text":""},{"location":"infrastructure/github_actions/#deploy-deploy","title":"Deploy (<code>deploy</code>)","text":"<ul> <li>Checks out documentation source</li> <li>Sets up Python environment</li> <li>Installs MkDocs and required plugins:</li> <li><code>mkdocs</code></li> <li><code>mkdocs-get-deps</code></li> <li><code>mkdocs-include-markdown-plugin</code></li> <li><code>mkdocs-macros-includex</code></li> <li><code>mkdocs-macros-plugin</code></li> <li><code>mkdocs-material</code></li> <li><code>mkdocs-material-extensions</code></li> <li><code>mkdocs-plantuml</code></li> <li><code>mkdocs_puml</code></li> <li><code>mkdocs_puml_file</code></li> <li>Builds MkDocs site</li> <li>Deploys to <code>pkmechpower.github.io</code> repository using SSH deploy key</li> <li>Uses force push to <code>master</code> branch</li> </ul>"},{"location":"infrastructure/github_actions/#required-secrets","title":"Required Secrets","text":"<ul> <li><code>DEPLOY_KEY</code>: SSH private key for deploying to GitHub Pages repository</li> </ul>"},{"location":"infrastructure/github_actions/#common-configurations","title":"Common Configurations","text":""},{"location":"infrastructure/github_actions/#compiler-settings","title":"Compiler Settings","text":"<ul> <li>C Standard: C11 (for embedded targets)</li> <li>C++ Standard: C++23</li> <li>C++ Extensions: OFF (disabled)</li> <li>Build System: Ninja (for host builds)</li> </ul>"},{"location":"infrastructure/github_actions/#arm-toolchain","title":"ARM Toolchain","text":"<ul> <li>Version: xPack ARM GCC 12.3.1-1.1</li> <li>Cached: Yes (to speed up builds)</li> <li>Targets: </li> <li>Cortex-M7 (STM32F7 for MCS_Front)</li> <li>Cortex-M7 + Cortex-M4 (STM32H7 dual-core for MCS_Back)</li> </ul>"},{"location":"infrastructure/github_actions/#test-output","title":"Test Output","text":"<ul> <li>Format: Google Test XML</li> <li>Location: <code>build/&lt;test_type&gt;/test-results.xml</code></li> </ul>"},{"location":"infrastructure/github_actions/#workflow-dependencies","title":"Workflow Dependencies","text":"<pre><code>mp_ci_windows.yaml\n\u251c\u2500\u2500 unit_tests \u2192 unit_tests_run\n\u251c\u2500\u2500 integration_tests \u2192 integration_tests_run\n\u251c\u2500\u2500 mcs_front (independent)\n\u2514\u2500\u2500 mcs_back (independent)\n\nmp_manual_unit_tests.yaml\n\u2514\u2500\u2500 unit_tests \u2192 unit_tests_run\n\nmp_manual_integration_tests.yaml\n\u2514\u2500\u2500 integration_tests \u2192 integration_tests_run\n\ndeploy_mk_docs.yaml\n\u2514\u2500\u2500 deploy (independent)\n</code></pre>"},{"location":"infrastructure/github_actions/#notes","title":"Notes","text":"<ol> <li>Submodule Strategy: Workflows only initialize required submodules to minimize checkout time</li> <li>Artifact Retention: Test executables are uploaded as artifacts for the test execution jobs</li> <li>Toolchain Caching: ARM GCC toolchain is cached between runs to improve build speed</li> <li>Test Filtering: All tests run with <code>--gtest_filter=*</code> (no filtering)</li> <li>Documentation Deployment: Automatic on every push to master, uses SSH for authentication</li> </ol>"},{"location":"infrastructure/logger/","title":"Logger and LoggerProxy Class","text":""},{"location":"infrastructure/logger/#overview","title":"Overview","text":"<p>The <code>Logger</code> and <code>LoggerProxy</code> classes provide a lightweight CSV logging facility for test data. <code>Logger</code> manages the file lifecycle and output stream, while <code>LoggerProxy</code> provides a convenient stream-based interface with automatic line termination and flushing.</p>"},{"location":"infrastructure/logger/#location","title":"Location","text":"<pre><code>software/tests/_test_helpers/mp_test_logger.h\n</code></pre>"},{"location":"infrastructure/logger/#architecture","title":"Architecture","text":"<pre>3abaad50c9b388d8a0c12b7cf11c62665b97c34f95c953d21d906fac627a7118fc682d687ece07b6b06c70e7f3e886af7f262dd80f133350f88c36d5e52f9bbb</pre><pre>8cb0ab3460afe9a7d4a4edf7a336eceed90a9ac168a344e4dd3d6a2996b2a8ff622c97ac38613a80d9db44e6dd229ae04f01bef67b4d2214476f65878a88638d</pre>"},{"location":"infrastructure/logger/#logger-class","title":"Logger Class","text":""},{"location":"infrastructure/logger/#overview_1","title":"Overview","text":"<p><code>Logger</code> manages a single CSV output file. It handles file creation, directory management, and provides low-level stream access.</p>"},{"location":"infrastructure/logger/#member-variables","title":"Member Variables","text":"<pre><code>private:\n    static inline std::filesystem::path m_log_directory = \"logs\";\n    std::ofstream *m_log_file{nullptr};\n</code></pre> <ul> <li><code>m_log_directory</code>: Static path to the logs directory (shared across all Logger instances)</li> <li><code>m_log_file</code>: Pointer to the output file stream (dynamically allocated)</li> </ul>"},{"location":"infrastructure/logger/#methods","title":"Methods","text":""},{"location":"infrastructure/logger/#constructor-and-destructor","title":"Constructor and Destructor","text":"<pre><code>Logger() = default;\n~Logger();\n</code></pre> <p>Destructor Behavior: Automatically frees the <code>m_log_file</code> pointer if it was allocated.</p>"},{"location":"infrastructure/logger/#register_log_file","title":"register_log_file()","text":"<pre><code>void register_log_file(\n    std::string const &amp;test_suite_name,\n    std::string const &amp;test_name,\n    std::string const &amp;suffix = \"\"\n);\n</code></pre> <p>Creates and opens a log file with automatic naming.</p> <p>Parameters:</p> <ul> <li><code>test_suite_name</code>: Name of the test suite (from Google Test)</li> <li><code>test_name</code>: Name of the test case (from Google Test)</li> <li><code>suffix</code>: Optional suffix to distinguish multiple loggers in the same test</li> </ul> <p>File Naming:</p> <pre><code>logs/&lt;test_suite_name&gt;_&lt;test_name&gt;_&lt;suffix&gt;.csv\n</code></pre> <p>Behavior:</p> <ol> <li>Creates <code>logs/</code> directory if it doesn't exist</li> <li>Constructs filename from parameters</li> <li>Replaces whitespace in suffix with underscores</li> <li>Deletes previous file pointer if exists</li> <li>Allocates new <code>std::ofstream</code> and opens file</li> </ol> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"SystemTest\", \"Voltage\", \"Main Data\");\n// Creates: logs/SystemTest_Voltage_Main_Data.csv\n</code></pre>"},{"location":"infrastructure/logger/#close_log","title":"close_log()","text":"<pre><code>void close_log();\n</code></pre> <p>Closes the log file if it's open.</p> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\n// ... write data ...\nlogger.close_log();\n</code></pre> <p>Note: Typically not needed as destructor handles cleanup.</p>"},{"location":"infrastructure/logger/#stream","title":"stream()","text":"<pre><code>std::ostream&amp; stream();\n</code></pre> <p>Provides direct access to the underlying output stream.</p> <p>Returns: Reference to the <code>std::ofstream</code></p> <p>Assertions: Asserts if <code>m_log_file</code> is null</p> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\nlogger.stream() &lt;&lt; \"Direct write\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"infrastructure/logger/#operator","title":"operator&lt;&lt;","text":"<pre><code>template &lt;typename T&gt;\nLogger&amp; operator&lt;&lt;(const T &amp;value);\n</code></pre> <p>Writes a value to the log file and returns the logger for chaining.</p> <p>Type Requirements: <code>T</code> must be streamable to <code>std::ostream</code></p> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\nlogger &lt;&lt; \"Time\" &lt;&lt; \",\" &lt;&lt; 1.23 &lt;&lt; std::endl;\n</code></pre> <p>Note: Manual comma insertion required. Prefer using <code>LoggerProxy</code> for automatic CSV formatting.</p>"},{"location":"infrastructure/logger/#loggerproxy-class","title":"LoggerProxy Class","text":""},{"location":"infrastructure/logger/#overview_2","title":"Overview","text":"<p><code>LoggerProxy</code> wraps a <code>Logger</code> reference and provides automatic CSV formatting with comma separation and line termination. It's designed to be used in a single expression for writing a complete CSV row.</p>"},{"location":"infrastructure/logger/#key-design-features","title":"Key Design Features","text":"<ol> <li>RAII Pattern: Destructor automatically completes the CSV row</li> <li>Automatic Commas: Each <code>operator&lt;&lt;</code> call adds a trailing comma</li> <li>Line Completion: Destructor removes the trailing comma and adds newline</li> <li>Automatic Flush: Ensures data is written to disk immediately</li> </ol>"},{"location":"infrastructure/logger/#member-variables_1","title":"Member Variables","text":"<pre><code>private:\n    Logger &amp;logger_;\n</code></pre> <ul> <li><code>logger_</code>: Reference to the underlying <code>Logger</code> object</li> </ul>"},{"location":"infrastructure/logger/#methods_1","title":"Methods","text":""},{"location":"infrastructure/logger/#constructor","title":"Constructor","text":"<pre><code>LoggerProxy(Logger &amp;logger);\n</code></pre> <p>Creates a proxy for the given logger.</p> <p>Parameters:</p> <ul> <li><code>logger</code>: Reference to the <code>Logger</code> to wrap</li> </ul> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\nLoggerProxy proxy(logger);\n</code></pre> <p>Note: Typically created via <code>get_logger_proxy()</code> helper function, not directly.</p>"},{"location":"infrastructure/logger/#operator_1","title":"operator&lt;&lt;","text":"<pre><code>template &lt;typename T&gt;\nLoggerProxy&amp; operator&lt;&lt;(const T &amp;value);\n</code></pre> <p>Writes a value followed by a comma to the logger.</p> <p>Type Requirements: <code>T</code> must be streamable to <code>std::ostream</code></p> <p>Returns: Reference to itself for chaining</p> <p>Example: <pre><code>proxy &lt;&lt; \"Time\" &lt;&lt; 1.23 &lt;&lt; 45.6;  // Writes: Time,1.23,45.6\n</code></pre></p>"},{"location":"infrastructure/logger/#destructor","title":"Destructor","text":"<pre><code>~LoggerProxy();\n</code></pre> <p>Behavior:</p> <ol> <li>Seeks back one character in the stream (removes trailing comma)</li> <li>Writes newline character</li> <li>Flushes the stream to ensure data is written</li> </ol> <p>Example Flow:</p> <pre><code>{\n    LoggerProxy proxy(logger);\n    proxy &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";  // Stream contains: A,B,C,\n}  // Destructor: removes last comma, adds newline, flushes\n   // Final stream: A,B,C\\n\n</code></pre>"},{"location":"infrastructure/logger/#helper-function","title":"Helper Function","text":""},{"location":"infrastructure/logger/#get_logger_proxy","title":"get_logger_proxy()","text":"<pre><code>LoggerProxy get_logger_proxy(Logger &amp;logger);\n</code></pre> <p>Factory function that creates a <code>LoggerProxy</code> for the given logger.</p> <p>Parameters:</p> <ul> <li><code>logger</code>: Reference to the <code>Logger</code> to wrap</li> </ul> <p>Returns: <code>LoggerProxy</code> object (by value)</p> <p>Example:</p> <pre><code>Logger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\n\n// Using helper function\nget_logger_proxy(logger) &lt;&lt; \"Time\" &lt;&lt; \"Value\";\n\n// Equivalent to:\nLoggerProxy(logger) &lt;&lt; \"Time\" &lt;&lt; \"Value\";\n</code></pre>"},{"location":"infrastructure/logger/#usage-patterns","title":"Usage Patterns","text":""},{"location":"infrastructure/logger/#basic-csv-writing","title":"Basic CSV Writing","text":"<pre><code>Logger logger;\nlogger.register_log_file(\"MyTest\", \"Case1\", \"Data\");\n\n// Write header\nget_logger_proxy(logger) &lt;&lt; \"Time\" &lt;&lt; \"Temperature\" &lt;&lt; \"Pressure\";\n\n// Write data rows\nget_logger_proxy(logger) &lt;&lt; 0.0 &lt;&lt; 20.5 &lt;&lt; 101.3;\nget_logger_proxy(logger) &lt;&lt; 0.1 &lt;&lt; 20.6 &lt;&lt; 101.4;\n</code></pre> <p>Output (Data.csv):</p> <pre><code>Time,Temperature,Pressure\n0.0,20.5,101.3\n0.1,20.6,101.4\n</code></pre>"},{"location":"infrastructure/logger/#multiple-data-types","title":"Multiple Data Types","text":"<pre><code>get_logger_proxy(logger) &lt;&lt; \"Name\" &lt;&lt; \"Count\" &lt;&lt; \"Active\" &lt;&lt; \"Value\";\nget_logger_proxy(logger) &lt;&lt; \"Sensor1\" &lt;&lt; 42 &lt;&lt; true &lt;&lt; 3.14159;\nget_logger_proxy(logger) &lt;&lt; \"Sensor2\" &lt;&lt; 17 &lt;&lt; false &lt;&lt; 2.71828;\n</code></pre> <p>Output: <pre><code>Name,Count,Active,Value\nSensor1,42,1,3.14159\nSensor2,17,0,2.71828\n</code></pre></p> <p>Note: Boolean values are output as <code>1</code> (true) or <code>0</code> (false).</p>"},{"location":"infrastructure/logger/#with-enums","title":"With Enums","text":"<pre><code>enum class State { IDLE, RUNNING, ERROR };\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, State s) {\n    switch (s) {\n        case State::IDLE: return os &lt;&lt; \"IDLE\";\n        case State::RUNNING: return os &lt;&lt; \"RUNNING\";\n        case State::ERROR: return os &lt;&lt; \"ERROR\";\n    }\n    return os;\n}\n\nget_logger_proxy(logger) &lt;&lt; \"Time\" &lt;&lt; \"State\" &lt;&lt; \"Code\";\nget_logger_proxy(logger) &lt;&lt; 1.0 &lt;&lt; State::RUNNING &lt;&lt; 200;\nget_logger_proxy(logger) &lt;&lt; 2.0 &lt;&lt; State::ERROR &lt;&lt; 500;\n</code></pre> <p>Output:</p> <pre><code>Time,State,Code\n1.0,RUNNING,200\n2.0,ERROR,500\n</code></pre>"},{"location":"infrastructure/logger/#complex-structures","title":"Complex Structures","text":"<pre><code>struct SensorData {\n    float temperature;\n    float pressure;\n    bool valid;\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SensorData&amp; data) {\n    return os &lt;&lt; data.temperature &lt;&lt; \",\" &lt;&lt; data.pressure &lt;&lt; \",\" &lt;&lt; data.valid;\n}\n\n// Note: Custom operator&lt;&lt; should NOT add trailing comma\n// LoggerProxy handles comma separation\nSensorData data1{20.5f, 101.3f, true};\nget_logger_proxy(logger) &lt;&lt; \"Time\" &lt;&lt; \"Sensor\";\nget_logger_proxy(logger) &lt;&lt; 1.0 &lt;&lt; data1;\n</code></pre> <p>Important: When overloading <code>operator&lt;&lt;</code> for custom types used with <code>LoggerProxy</code>, the custom operator should format the data without trailing commas, as <code>LoggerProxy</code> handles comma separation.</p>"},{"location":"infrastructure/logger/#conditional-logging","title":"Conditional Logging","text":"<pre><code>for (int i = 0; i &lt; 100; i++) {\n    float value = compute(i);\n\n    // Log only significant changes\n    if (abs(value - last_value) &gt; threshold) {\n        get_logger_proxy(logger) &lt;&lt; i &lt;&lt; value;\n        last_value = value;\n    }\n}\n</code></pre>"},{"location":"infrastructure/logger/#timestamp-formatting","title":"Timestamp Formatting","text":"<pre><code>#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n\nstd::string format_timestamp(float time) {\n    std::ostringstream oss;\n    oss &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; time;\n    return oss.str();\n}\n\nget_logger_proxy(logger) &lt;&lt; format_timestamp(1.23456) &lt;&lt; \"Value\";\n// Outputs: 1.235,Value\n</code></pre>"},{"location":"infrastructure/logger/#internal-mechanics","title":"Internal Mechanics","text":""},{"location":"infrastructure/logger/#line-writing-process","title":"Line Writing Process","text":"<ol> <li>Creation: <code>LoggerProxy</code> is created with a reference to <code>Logger</code></li> <li>Data Writing: Each <code>operator&lt;&lt;</code> call writes value + comma</li> <li>Destruction: Destructor performs cleanup:</li> </ol> <pre><code>long pos = logger_.stream().tellp();           // Get current position\nlogger_.stream().seekp(pos - 1);               // Back up one char\nlogger_.stream() &lt;&lt; std::endl;                 // Write newline\nlogger_.stream().flush();                      // Force write to disk\n</code></pre>"},{"location":"infrastructure/logger/#example-trace","title":"Example Trace","text":"<pre><code>// Code:\nget_logger_proxy(logger) &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";\n\n// Step-by-step stream contents:\n// 1. After &lt;&lt; \"A\":  \"A,\"\n// 2. After &lt;&lt; \"B\":  \"A,B,\"\n// 3. After &lt;&lt; \"C\":  \"A,B,C,\"\n// 4. Destructor:    \"A,B,C\\n\" (comma removed, newline added, flushed)\n</code></pre>"},{"location":"infrastructure/logger/#memory-management","title":"Memory Management","text":""},{"location":"infrastructure/logger/#logger-lifecycle","title":"Logger Lifecycle","text":"<pre><code>// Typical lifecycle managed by UnitTest\nclass UnitTest {\n    std::map&lt;std::string, Logger&gt; m_loggers;  // Stored by value\n\n    bool create_logger(std::string const &amp;name) {\n        m_loggers[name] = Logger();  // Default constructed\n        m_loggers[name].register_log_file(suite, test, name);\n        return true;\n    }\n\n    // Automatic cleanup in map destructor\n    ~UnitTest() = default;  // m_loggers destroyed, Logger destructors called\n};\n</code></pre>"},{"location":"infrastructure/logger/#file-pointer-management","title":"File Pointer Management","text":"<p>The <code>Logger</code> class uses a raw pointer (<code>std::ofstream*</code>) for the file:</p> <pre><code>Logger::~Logger() {\n    if (m_log_file) {\n        free(m_log_file);  // Note: Should be 'delete', not 'free'\n    }\n}\n</code></pre> <p>Potential Issue: The destructor uses <code>free()</code> instead of <code>delete</code>. This is likely a bug since <code>m_log_file</code> is allocated with <code>new</code>:</p> <pre><code>m_log_file = new std::ofstream(filepath);  // allocated with new\n</code></pre> <p>Should be:</p> <pre><code>Logger::~Logger() {\n    if (m_log_file) {\n        delete m_log_file;  // Correct: delete matches new\n    }\n}\n</code></pre>"},{"location":"infrastructure/logger/#best-practices","title":"Best Practices","text":""},{"location":"infrastructure/logger/#1-always-use-loggerproxy-for-csv","title":"1. Always Use LoggerProxy for CSV","text":"<pre><code>// GOOD - Automatic CSV formatting\nget_logger_proxy(logger) &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";\n\n// BAD - Manual formatting required\nlogger &lt;&lt; \"A\" &lt;&lt; \",\" &lt;&lt; \"B\" &lt;&lt; \",\" &lt;&lt; \"C\" &lt;&lt; std::endl;\n</code></pre>"},{"location":"infrastructure/logger/#2-one-proxy-per-line","title":"2. One Proxy Per Line","text":"<pre><code>// GOOD - Each statement is one CSV row\nget_logger_proxy(logger) &lt;&lt; \"Header1\" &lt;&lt; \"Header2\";\nget_logger_proxy(logger) &lt;&lt; \"Data1\" &lt;&lt; \"Data2\";\n\n// BAD - Don't reuse proxy across lines\nauto proxy = get_logger_proxy(logger);\nproxy &lt;&lt; \"Header1\" &lt;&lt; \"Header2\";  // This line is complete when proxy destructs\nproxy &lt;&lt; \"Data1\" &lt;&lt; \"Data2\";      // This won't work as expected\n</code></pre>"},{"location":"infrastructure/logger/#3-consistent-column-count","title":"3. Consistent Column Count","text":"<pre><code>// GOOD\nget_logger_proxy(logger) &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";\nget_logger_proxy(logger) &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3;\nget_logger_proxy(logger) &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 6;\n\n// BAD - Inconsistent columns\nget_logger_proxy(logger) &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";\nget_logger_proxy(logger) &lt;&lt; 1 &lt;&lt; 2;           // Missing column!\nget_logger_proxy(logger) &lt;&lt; 4 &lt;&lt; 5 &lt;&lt; 6 &lt;&lt; 7; // Extra column!\n</code></pre>"},{"location":"infrastructure/logger/#4-handle-commas-in-string-data","title":"4. Handle Commas in String Data","text":"<pre><code>// Be aware: commas in strings will break CSV format\nstd::string description = \"Temperature, degrees C\";\nget_logger_proxy(logger) &lt;&lt; description;  // Results in extra columns!\n\n// Solution: Quote strings with commas (manual handling required)\nstd::string safe_description = \"\\\"Temperature, degrees C\\\"\";\nget_logger_proxy(logger) &lt;&lt; safe_description;\n</code></pre>"},{"location":"infrastructure/logger/#5-flush-critical-data","title":"5. Flush Critical Data","text":"<p><code>LoggerProxy</code> automatically flushes after each line, ensuring data persistence:</p> <pre><code>for (int i = 0; i &lt; 1000000; i++) {\n    if (i % 1000 == 0) {\n        get_logger_proxy(logger) &lt;&lt; i &lt;&lt; compute(i);\n        // Flushed automatically - safe even if test crashes\n    }\n}\n</code></pre>"},{"location":"infrastructure/logger/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"infrastructure/logger/#1-forgetting-register_log_file","title":"1. Forgetting register_log_file()","text":"<pre><code>// WRONG - will assert\nLogger logger;\nget_logger_proxy(logger) &lt;&lt; \"Data\";  // m_log_file is nullptr!\n\n// CORRECT\nLogger logger;\nlogger.register_log_file(\"Test\", \"Case\", \"Data\");\nget_logger_proxy(logger) &lt;&lt; \"Data\";\n</code></pre>"},{"location":"infrastructure/logger/#2-reusing-loggerproxy","title":"2. Reusing LoggerProxy","text":"<pre><code>// WRONG - proxy destructor is called when line ends\nauto proxy = get_logger_proxy(logger);\nproxy &lt;&lt; \"A\" &lt;&lt; \"B\";  // Line written here when expression ends\nproxy &lt;&lt; \"C\" &lt;&lt; \"D\";  // Doesn't work - proxy is already used\n\n// CORRECT - new proxy for each line\nget_logger_proxy(logger) &lt;&lt; \"A\" &lt;&lt; \"B\";\nget_logger_proxy(logger) &lt;&lt; \"C\" &lt;&lt; \"D\";\n</code></pre>"},{"location":"infrastructure/logger/#3-manual-vs-automatic-formatting","title":"3. Manual vs. Automatic Formatting","text":"<pre><code>// Mixing styles leads to confusion\nlogger &lt;&lt; \"A\" &lt;&lt; \",\";                    // Manual\nget_logger_proxy(logger) &lt;&lt; \"B\" &lt;&lt; \"C\";  // Automatic\n\n// Pick one style and stick with it\n</code></pre>"},{"location":"infrastructure/logger/#4-expecting-custom-precision","title":"4. Expecting Custom Precision","text":"<pre><code>// Default precision may not be what you want\nfloat pi = 3.14159265359;\nget_logger_proxy(logger) &lt;&lt; pi;  // Output depends on default precision\n\n// Solution: Format before logging\nstd::ostringstream oss;\noss &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; pi;\nget_logger_proxy(logger) &lt;&lt; oss.str();  // 3.141593\n</code></pre>"},{"location":"infrastructure/logger/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Flushing Overhead: Each line is flushed, ensuring data safety but impacting performance for high-frequency logging</p> </li> <li> <p>File I/O: Consider logging frequency in tight loops:</p> </li> </ol> <pre><code>// High overhead - 1M file operations\nfor (int i = 0; i &lt; 1000000; i++) {\n    get_logger_proxy(logger) &lt;&lt; i &lt;&lt; compute(i);\n}\n\n// Better - 1000 file operations\nfor (int i = 0; i &lt; 1000000; i++) {\n    if (i % 1000 == 0) {\n        get_logger_proxy(logger) &lt;&lt; i &lt;&lt; compute(i);\n    }\n}\n</code></pre> <ol> <li>String Allocation: <code>LoggerProxy</code> is lightweight but each call creates a temporary object</li> </ol>"},{"location":"infrastructure/logger/#limitations","title":"Limitations","text":"<ol> <li>CSV Only: No support for other formats (JSON, XML, binary)</li> <li>No Buffering Control: Flushing is automatic and cannot be disabled</li> <li>No Escaping: Strings containing commas break CSV format</li> <li>No Quoting: No automatic quoting for string fields</li> <li>Fixed Delimiter: Comma is hardcoded, no alternative delimiters</li> <li>No Compression: Large logs consume significant disk space</li> </ol>"},{"location":"infrastructure/logger/#see-also","title":"See Also","text":"<ul> <li>UnitTest - Primary user of Logger and LoggerProxy classes</li> <li>RTOS_Test - Uses logging for integration test data capture</li> <li>MCS_Back_Test - Examples of real-world logger usage</li> <li>CSV format specification</li> <li>C++ stream I/O documentation</li> </ul>"},{"location":"infrastructure/rtos_test/","title":"RTOS_Test Class","text":""},{"location":"infrastructure/rtos_test/#overview","title":"Overview","text":"<p><code>RTOS_Test</code> is a base test class for integration testing FreeRTOS-based embedded systems in a simulated Windows environment. It provides infrastructure for creating tasks, managing queues, triggering interrupts, and simulating CAN communication without requiring actual hardware.</p>"},{"location":"infrastructure/rtos_test/#location","title":"Location","text":"<pre><code>software/tests/_test_helpers/freertos/mp_rtos_test.h\nsoftware/tests/_test_helpers/freertos/mp_rtos_test.cpp\n</code></pre>"},{"location":"infrastructure/rtos_test/#key-features","title":"Key Features","text":"<ul> <li> <p>Task Management: Create and track FreeRTOS tasks that are automatically cleaned up</p> </li> <li> <p>Queue Management: Create named queues with automatic lifecycle management</p> </li> <li> <p>Message Buffers: Manage FreeRTOS message buffers</p> </li> <li> <p>ISR Simulation: Register and trigger interrupt service routines</p> </li> <li> <p>CAN Communication: Mock CAN interfaces for testing multi-node systems</p> </li> <li> <p>Time Control: Precisely control simulation time progression</p> </li> <li> <p>Interface Mocking: Configure which hardware interfaces (CAN, ADC, etc.) are enabled</p> </li> </ul>"},{"location":"infrastructure/rtos_test/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>::testing::Test (Google Test)\n    \u2514\u2500\u2500 UnitTest\n        \u2514\u2500\u2500 RTOS_Test\n</code></pre>"},{"location":"infrastructure/rtos_test/#test-configuration","title":"Test Configuration","text":""},{"location":"infrastructure/rtos_test/#configuration-structure","title":"Configuration Structure","text":"<pre><code>struct Test_Configuration {\n    struct Interfaces {\n        struct CAN_Interface {\n            bool can_1_enabled{false};\n            bool can_2_enabled{false};\n        } can;\n    } interfaces;\n};\n</code></pre>"},{"location":"infrastructure/rtos_test/#creating-configurations","title":"Creating Configurations","text":"<p>Use the static factory method to create board-specific configurations:</p> <pre><code>static Test_Configuration make_test_configuration(Board_Names board_name);\n</code></pre> <p>Supported board names:</p> <ul> <li> <p><code>Board_Names::GENERIC</code> - Single CAN interface</p> </li> <li> <p><code>Board_Names::MCS_FRONT</code> - Single CAN interface</p> </li> <li> <p><code>Board_Names::MCS_BACK</code> - Dual CAN interfaces</p> </li> </ul>"},{"location":"infrastructure/rtos_test/#core-methods","title":"Core Methods","text":""},{"location":"infrastructure/rtos_test/#setup-and-teardown","title":"Setup and Teardown","text":"<pre><code>protected:\n    void SetUp() override;\n    void TearDown() override;\n</code></pre> <p>SetUp(): Called before each test. Initializes interfaces based on configuration.</p> <p>TearDown(): Called after each test. Cleans up all tracked resources (tasks, queues, message buffers, ISR vectors).</p>"},{"location":"infrastructure/rtos_test/#time-simulation","title":"Time Simulation","text":""},{"location":"infrastructure/rtos_test/#simulate_for","title":"simulate_for()","text":"<pre><code>void simulate_for(SI::Time time);\n</code></pre> <p>Advances simulation by a specified duration with 1ms time steps.</p> <p>Parameters:</p> <ul> <li><code>time</code>: Duration to simulate (in seconds, using SI units)</li> </ul> <p>Example:</p> <pre><code>// Simulate for 0.5 seconds\nsimulate_for(0.5f);\n</code></pre>"},{"location":"infrastructure/rtos_test/#simulate_until","title":"simulate_until()","text":"<pre><code>void simulate_until(std::function&lt;bool(void)&gt; const &amp;condition, SI::Time timeout = 1.0f);\n</code></pre> <p>Advances simulation until a condition is met or timeout occurs.</p> <p>Parameters:</p> <ul> <li> <p><code>condition</code>: Lambda function returning <code>true</code> when desired state is reached</p> </li> <li> <p><code>timeout</code>: Maximum time to wait (default: 1.0 second)</p> </li> </ul> <p>Example:</p> <pre><code>// Wait until CAN message is received\nauto message_received = [&amp;]() { return can_mock-&gt;get_rx_queue_size() &gt; 0; };\nsimulate_until(message_received, 2.0f);\n</code></pre>"},{"location":"infrastructure/rtos_test/#get_simulation_time","title":"get_simulation_time()","text":"<pre><code>SI::Time get_simulation_time() const;\n</code></pre> <p>Returns the current simulation time in seconds.</p>"},{"location":"infrastructure/rtos_test/#task-management","title":"Task Management","text":""},{"location":"infrastructure/rtos_test/#create_tracked_task","title":"create_tracked_task()","text":"<pre><code>void create_tracked_task(\n    TaskFunction_t fn,\n    const char *name,\n    uint16_t stack,\n    void *params,\n    UBaseType_t prio\n);\n</code></pre> <p>Creates a FreeRTOS task that is automatically deleted during teardown.</p> <p>Parameters:</p> <ul> <li> <p><code>fn</code>: Task function pointer</p> </li> <li> <p><code>name</code>: Task name for debugging</p> </li> <li> <p><code>stack</code>: Stack size in words</p> </li> <li> <p><code>params</code>: Task parameters</p> </li> <li> <p><code>prio</code>: Task priority (0 = lowest, configMAX_PRIORITIES-1 = highest)</p> </li> </ul> <p>Example:</p> <pre><code>create_tracked_task(\n    Application_Task,\n    \"app_task\",\n    10 * configMINIMAL_STACK_SIZE,\n    &amp;task_args,\n    configMAX_PRIORITIES - 2\n);\n</code></pre>"},{"location":"infrastructure/rtos_test/#queue-management","title":"Queue Management","text":""},{"location":"infrastructure/rtos_test/#create_tracked_queue","title":"create_tracked_queue()","text":"<pre><code>void create_tracked_queue(\n    const UBaseType_t length,\n    const UBaseType_t size,\n    std::string_view name\n);\n</code></pre> <p>Creates a named FreeRTOS queue that is automatically deleted during teardown.</p> <p>Parameters:</p> <ul> <li> <p><code>length</code>: Maximum number of items in the queue</p> </li> <li> <p><code>size</code>: Size of each item in bytes</p> </li> <li> <p><code>name</code>: Unique identifier for retrieving the queue</p> </li> </ul> <p>Example:</p> <pre><code>create_tracked_queue(10, sizeof(uint32_t), \"adc_queue\");\n</code></pre>"},{"location":"infrastructure/rtos_test/#get_queue","title":"get_queue()","text":"<pre><code>QueueHandle_t get_queue(std::string_view name);\n</code></pre> <p>Retrieves a previously created queue by name.</p> <p>Example:</p> <pre><code>QueueHandle_t adc_queue = get_queue(\"adc_queue\");\n</code></pre>"},{"location":"infrastructure/rtos_test/#message-buffer-management","title":"Message Buffer Management","text":""},{"location":"infrastructure/rtos_test/#create_tracked_message_buffer","title":"create_tracked_message_buffer()","text":"<pre><code>MessageBufferHandle_t create_tracked_message_buffer(size_t size);\n</code></pre> <p>Creates a FreeRTOS message buffer that is automatically deleted during teardown.</p> <p>Parameters:</p> <ul> <li><code>size</code>: Buffer size in bytes</li> </ul> <p>Returns: Handle to the created message buffer</p> <p>Example:</p> <pre><code>MessageBufferHandle_t tx_buffer = create_tracked_message_buffer(200);\n</code></pre>"},{"location":"infrastructure/rtos_test/#interrupt-service-routines","title":"Interrupt Service Routines","text":""},{"location":"infrastructure/rtos_test/#register_isr","title":"register_isr()","text":"<pre><code>void register_isr(Simulator::Interrupt_Vector id, Simulator::Interrupt_Service_Routine isr);\n</code></pre> <p>Registers an interrupt service routine for simulation.</p> <p>Parameters:</p> <ul> <li> <p><code>id</code>: Interrupt vector identifier</p> </li> <li> <p><code>isr</code>: Function pointer to ISR (must return <code>uint32_t</code>)</p> </li> </ul> <p>Example:</p> <pre><code>register_isr(\n    Simulator::Interrupt_Vector::MCS_BACK_ADC_DMA,\n    Simulator::HAL_ADC_ConvCpltCallback_ISR_Mock&lt;Operation::MCS_Back::ADC_Data&gt;\n);\n</code></pre>"},{"location":"infrastructure/rtos_test/#trigger_isr","title":"trigger_isr()","text":"<pre><code>void trigger_isr(Simulator::Interrupt_Vector id);\n</code></pre> <p>Manually triggers a registered interrupt.</p> <p>Example:</p> <pre><code>trigger_isr(Simulator::Interrupt_Vector::MCS_BACK_ADC_DMA);\n</code></pre>"},{"location":"infrastructure/rtos_test/#can-communication","title":"CAN Communication","text":""},{"location":"infrastructure/rtos_test/#receive_can_message","title":"receive_CAN_message()","text":"<pre><code>void receive_CAN_message(\n    Operation::CAN_Instance const &amp;can_instance,\n    Firmware::CAN_Frame const &amp;frame\n);\n</code></pre> <p>Simulates receiving a CAN message on a specific interface.</p> <p>Parameters:</p> <ul> <li> <p><code>can_instance</code>: CAN interface (CAN_1 or CAN_2)</p> </li> <li> <p><code>frame</code>: CAN frame to receive</p> </li> </ul> <p>Example:</p> <pre><code>TS_Activate_Msg msg{true};\nauto frame = CAN_Message_Traits&lt;TS_Activate_Msg&gt;::encode(msg);\nreceive_CAN_message(Operation::CAN_Instance::CAN_1, frame);\n</code></pre>"},{"location":"infrastructure/rtos_test/#get_can_mock","title":"get_can_mock()","text":"<pre><code>Simulator::CAN_Handler_Mock* get_can_mock(Operation::CAN_Instance const &amp;can_instance);\n</code></pre> <p>Retrieves the CAN mock for direct manipulation or inspection.</p> <p>Example:</p> <pre><code>auto can_mock = get_can_mock(Operation::CAN_Instance::CAN_1);\nEXPECT_EQ(can_mock-&gt;get_tx_queue_size(), 5);\n</code></pre>"},{"location":"infrastructure/rtos_test/#simulation-updates","title":"Simulation Updates","text":""},{"location":"infrastructure/rtos_test/#register_simulation_update","title":"register_simulation_update()","text":"<pre><code>void register_simulation_update(std::function&lt;void()&gt; callback);\n</code></pre> <p>Registers a callback that is executed every simulation step (1ms).</p> <p>Use Cases:</p> <ul> <li> <p>Periodic sensor updates</p> </li> <li> <p>Simulated hardware behavior</p> </li> <li> <p>Test state tracking</p> </li> </ul> <p>Example:</p> <pre><code>register_simulation_update([this]() {\n    adc_periodic_hook.update();\n});\n</code></pre>"},{"location":"infrastructure/rtos_test/#usage-patterns","title":"Usage Patterns","text":""},{"location":"infrastructure/rtos_test/#basic-test-structure","title":"Basic Test Structure","text":"<pre><code>class MySystemTest : public RTOS_Test {\npublic:\n    MySystemTest() : RTOS_Test(make_test_configuration(Board_Names::MCS_BACK)) {}\n\nprotected:\n    void SetUp() override {\n        Base::SetUp();\n\n        // Create resources\n        create_tracked_task(MyTask, \"my_task\", configMINIMAL_STACK_SIZE, nullptr, 1);\n        create_tracked_queue(10, sizeof(uint32_t), \"my_queue\");\n\n        // Register ISRs\n        register_isr(Simulator::Interrupt_Vector::CAN_1_RX, CAN_1_Rx_ISR_Mock);\n    }\n};\n\nTEST_F(MySystemTest, BasicOperation) {\n    // Simulate for 100ms\n    simulate_for(0.1f);\n\n    // Verify expected behavior\n    EXPECT_EQ(get_queue(\"my_queue\")-&gt;uxMessagesWaiting, 0);\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#testing-can-communication","title":"Testing CAN Communication","text":"<pre><code>TEST_F(MySystemTest, ReceivesCANMessage) {\n    // Create and encode message\n    SomeMessage msg{42};\n    auto frame = CAN_Message_Traits&lt;SomeMessage&gt;::encode(msg);\n\n    // Simulate receiving\n    receive_CAN_message(Operation::CAN_Instance::CAN_1, frame);\n\n    // Wait for processing\n    simulate_for(0.01f);\n\n    // Verify response\n    auto can_mock = get_can_mock(Operation::CAN_Instance::CAN_1);\n    EXPECT_GT(can_mock-&gt;get_tx_queue_size(), 0);\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#testing-with-conditions","title":"Testing with Conditions","text":"<pre><code>TEST_F(MySystemTest, WaitsForCondition) {\n    // Define success condition\n    auto is_ready = [&amp;]() {\n        return system_state == READY;\n    };\n\n    // Wait up to 1 second for condition\n    simulate_until(is_ready, 1.0f);\n\n    // Condition should be met (assertion in simulate_until)\n    EXPECT_EQ(system_state, READY);\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#periodic-simulation-updates","title":"Periodic Simulation Updates","text":"<pre><code>void SetUp() override {\n    Base::SetUp();\n\n    // Register ADC update hook\n    register_simulation_update([this]() {\n        m_adc_hook.update();\n    });\n\n    // Register state logger\n    register_simulation_update([this]() {\n        log_system_state();\n    });\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#important-notes","title":"Important Notes","text":""},{"location":"infrastructure/rtos_test/#resource-management","title":"Resource Management","text":"<p>All resources created through tracked methods are automatically cleaned up during <code>TearDown()</code>:</p> <ul> <li> <p>Tasks are deleted</p> </li> <li> <p>Queues are deleted</p> </li> <li> <p>Message buffers are deleted</p> </li> <li> <p>ISR vectors are cleared</p> </li> </ul>"},{"location":"infrastructure/rtos_test/#time-granularity","title":"Time Granularity","text":"<p>Simulation progresses in 1ms steps. This is hardcoded in <code>simulate_for()</code>:</p> <pre><code>static SI::Time const step{1e-3f};  // 1ms\n</code></pre>"},{"location":"infrastructure/rtos_test/#thread-safety","title":"Thread Safety","text":"<p>The test framework uses FreeRTOS running in a separate thread. Be aware of:</p> <ul> <li> <p>Race conditions between test thread and RTOS tasks</p> </li> <li> <p>Need for proper synchronization when accessing shared state</p> </li> <li> <p>Use of <code>vTaskDelay()</code> for timing in the test thread</p> </li> </ul>"},{"location":"infrastructure/rtos_test/#configuration-requirements","title":"Configuration Requirements","text":"<p>Interface configuration must be done in the constructor:</p> <pre><code>// CORRECT\nMyTest() : RTOS_Test(make_test_configuration(Board_Names::MCS_BACK)) {}\n\n// INCORRECT - too late\nvoid SetUp() override {\n    // Configuration already locked\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#best-practices","title":"Best Practices","text":"<ol> <li>Always call base methods: When overriding <code>SetUp()</code> or <code>TearDown()</code>, call the base class version</li> </ol> <pre><code>void SetUp() override {\n    Base::SetUp();  // Essential!\n    // Your setup code\n}\n</code></pre> <ol> <li>Use descriptive names: Queue names should be descriptive and unique</li> </ol> <pre><code>create_tracked_queue(10, sizeof(Data), \"sensor_data_queue\");\n</code></pre> <ol> <li>Check simulation time: Be aware of how long tests take</li> </ol> <pre><code>auto start = get_simulation_time();\nsimulate_until(condition);\nauto duration = get_simulation_time() - start;\nprint_info(\"Test took \" + std::to_string(duration) + \"s\");\n</code></pre> <ol> <li>Use condition-based waiting: Prefer <code>simulate_until()</code> over fixed delays</li> </ol> <pre><code>// GOOD\nsimulate_until([&amp;]() { return data_received; });\n\n// LESS GOOD\nsimulate_for(1.0f);  // May be too short or too long\n</code></pre> <ol> <li>Clean up state between tests: Ensure test independence by resetting mock counters</li> </ol> <pre><code>void TearDown() override {\n    get_can_mock(CAN_Instance::CAN_1)-&gt;reset_no_transmitted_messages();\n    Base::TearDown();\n}\n</code></pre>"},{"location":"infrastructure/rtos_test/#limitations","title":"Limitations","text":"<ul> <li> <p>No hardware access: Tests run in simulation only</p> </li> <li> <p>Timing accuracy: Limited by Windows thread scheduler (typically \u00b11-2ms)</p> </li> <li> <p>Single core: No true multi-core testing (SMP config not supported)</p> </li> <li> <p>ISR fidelity: Simulated ISRs don't have hardware timing characteristics</p> </li> <li> <p>No DMA: Direct memory access must be explicitly simulated</p> </li> </ul>"},{"location":"infrastructure/rtos_test/#see-also","title":"See Also","text":"<ul> <li> <p>MCS_Back_Test - Specialized test class for MCS_Back board</p> </li> <li> <p>UnitTest - Base class providing logging functionality</p> </li> <li> <p>Google Test documentation for assertion macros and test structure</p> </li> </ul>"},{"location":"infrastructure/unit_test/","title":"UnitTest Class","text":""},{"location":"infrastructure/unit_test/#overview","title":"Overview","text":"<p><code>UnitTest</code> is the base test class that provides logging capabilities and utility functions for all tests in the MP test framework. It extends Google Test's <code>::testing::Test</code> class and serves as the foundation for both unit tests and integration tests.</p>"},{"location":"infrastructure/unit_test/#location","title":"Location","text":"<pre><code>software/tests/_test_helpers/mp_unit_test.h\n</code></pre>"},{"location":"infrastructure/unit_test/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>::testing::Test (Google Test)\n    \u2514\u2500\u2500 UnitTest\n        \u2514\u2500\u2500 RTOS_Test\n            \u2514\u2500\u2500 MCS_Back_Test\n</code></pre>"},{"location":"infrastructure/unit_test/#key-features","title":"Key Features","text":"<ul> <li>Multi-Logger Support: Create multiple named loggers per test</li> <li>Automatic File Management: Loggers are automatically created and cleaned up</li> <li>CSV Output: Structured logging to CSV files for data analysis</li> <li>Test Context Integration: Log file names automatically include test suite and test name</li> <li>Console Output: Colored console messages for information and errors</li> <li>Directory Management: Automatic creation of log directory structure</li> </ul>"},{"location":"infrastructure/unit_test/#core-methods","title":"Core Methods","text":""},{"location":"infrastructure/unit_test/#logger-management","title":"Logger Management","text":""},{"location":"infrastructure/unit_test/#create_logger","title":"create_logger()","text":"<pre><code>bool create_logger(std::string const &amp;name);\n</code></pre> <p>Creates a named logger for the current test. The logger outputs to a CSV file with automatic naming.</p> <p>Parameters:</p> <ul> <li><code>name</code>: Unique identifier for this logger within the test</li> </ul> <p>Returns:</p> <ul> <li><code>true</code>: Logger created successfully</li> <li><code>false</code>: Logger with this name already exists</li> </ul> <p>File Naming Convention:</p> <pre><code>logs/&lt;TestSuite&gt;_&lt;TestName&gt;_&lt;LoggerName&gt;.csv\n</code></pre> <p>Example:</p> <pre><code>TEST_F(MyTest, VoltageMonitoring) {\n    create_logger(\"Voltage Data\");\n    create_logger(\"Error Status\");\n\n    // Creates:\n    // logs/MyTest_VoltageMonitoring_Voltage_Data.csv\n    // logs/MyTest_VoltageMonitoring_Error_Status.csv\n}\n</code></pre> <p>Special Character Handling: Whitespace in logger names is automatically converted to underscores:</p> <pre><code>create_logger(\"Motor Driver Status\");  // Creates: Motor_Driver_Status.csv\n</code></pre>"},{"location":"infrastructure/unit_test/#get_logger","title":"get_logger()","text":"<pre><code>LoggerProxy get_logger(std::string const &amp;name);\n</code></pre> <p>Retrieves a previously created logger for writing data.</p> <p>Parameters:</p> <ul> <li><code>name</code>: Name of the logger (must match name used in <code>create_logger()</code>)</li> </ul> <p>Returns: <code>LoggerProxy</code> object for stream-based logging</p> <p>Example:</p> <pre><code>create_logger(\"Data\");\nget_logger(\"Data\") &lt;&lt; \"Time\" &lt;&lt; \"Value\" &lt;&lt; \"Status\";\n</code></pre>"},{"location":"infrastructure/unit_test/#console-output","title":"Console Output","text":""},{"location":"infrastructure/unit_test/#print_info","title":"print_info()","text":"<pre><code>static void print_info(std::string_view const &amp;message);\n</code></pre> <p>Prints an informational message to the console in yellow color.</p> <p>Format:</p> <pre><code>[   INFO   ] &lt;message&gt;\n</code></pre> <p>Example:</p> <pre><code>UnitTest::print_info(\"Initializing test hardware\");\nUnitTest::print_info(\"Waiting for state transition\");\n</code></pre>"},{"location":"infrastructure/unit_test/#print_error","title":"print_error()","text":"<pre><code>static void print_error(std::string_view const &amp;message);\n</code></pre> <p>Prints an error message to the console in red color.</p> <p>Format:</p> <pre><code>[   ERROR   ] &lt;message&gt;\n</code></pre> <p>Example:</p> <pre><code>if (!condition_met) {\n    UnitTest::print_error(\"Timeout waiting for response\");\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#test-lifecycle-hooks","title":"Test Lifecycle Hooks","text":""},{"location":"infrastructure/unit_test/#teardown","title":"TearDown()","text":"<pre><code>virtual void TearDown() override;\n</code></pre> <p>Called after each test. Automatically clears all loggers and calls base class teardown.</p> <p>Important: When overriding, always call the base method:</p> <pre><code>void TearDown() override {\n    // Your cleanup code\n    Base::TearDown();  // Essential!\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#setuptestsuite-teardowntestsuite","title":"SetUpTestSuite() / TearDownTestSuite()","text":"<pre><code>static void SetUpTestSuite();\nstatic void TearDownTestSuite();\n</code></pre> <p>Called once before/after all tests in the test suite. Default implementation calls Google Test base methods.</p>"},{"location":"infrastructure/unit_test/#logger-usage-patterns","title":"Logger Usage Patterns","text":""},{"location":"infrastructure/unit_test/#basic-logging","title":"Basic Logging","text":"<pre><code>TEST_F(MyTest, SimpleLogging) {\n    // Create logger\n    create_logger(\"Test Data\");\n\n    // Write header\n    get_logger(\"Test Data\") &lt;&lt; \"Time\" &lt;&lt; \"Temperature\" &lt;&lt; \"Pressure\";\n\n    // Write data rows\n    for (int i = 0; i &lt; 10; i++) {\n        float time = i * 0.1f;\n        float temp = 20.0f + i;\n        float pressure = 100.0f + i * 2;\n\n        get_logger(\"Test Data\") &lt;&lt; time &lt;&lt; temp &lt;&lt; pressure;\n    }\n}\n</code></pre> <p>Output (Test_Data.csv):</p> <pre><code>Time,Temperature,Pressure\n0.0,20.0,100.0\n0.1,21.0,102.0\n0.2,22.0,104.0\n...\n</code></pre>"},{"location":"infrastructure/unit_test/#multiple-loggers","title":"Multiple Loggers","text":"<pre><code>TEST_F(MyTest, MultipleLoggers) {\n    create_logger(\"Sensor Data\");\n    create_logger(\"Error Log\");\n    create_logger(\"State Machine\");\n\n    // Each logger has independent headers and data\n    get_logger(\"Sensor Data\") &lt;&lt; \"Time\" &lt;&lt; \"Value\";\n    get_logger(\"Error Log\") &lt;&lt; \"Time\" &lt;&lt; \"Error Code\" &lt;&lt; \"Message\";\n    get_logger(\"State Machine\") &lt;&lt; \"Time\" &lt;&lt; \"State\" &lt;&lt; \"Flags\";\n\n    // Write to different loggers as needed\n    get_logger(\"Sensor Data\") &lt;&lt; 0.0f &lt;&lt; 42.0f;\n    get_logger(\"Error Log\") &lt;&lt; 0.0f &lt;&lt; 1 &lt;&lt; \"Initialization failed\";\n    get_logger(\"State Machine\") &lt;&lt; 0.0f &lt;&lt; \"INIT\" &lt;&lt; 0x00;\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#logging-in-loops","title":"Logging in Loops","text":"<pre><code>TEST_F(MyTest, TimeSeriesData) {\n    create_logger(\"Simulation\");\n    get_logger(\"Simulation\") &lt;&lt; \"Time\" &lt;&lt; \"Position\" &lt;&lt; \"Velocity\" &lt;&lt; \"Acceleration\";\n\n    float dt = 0.01f;\n    for (int step = 0; step &lt; 1000; step++) {\n        float time = step * dt;\n\n        // Compute values\n        float pos = compute_position(time);\n        float vel = compute_velocity(time);\n        float acc = compute_acceleration(time);\n\n        // Log every 10th step to reduce file size\n        if (step % 10 == 0) {\n            get_logger(\"Simulation\") &lt;&lt; time &lt;&lt; pos &lt;&lt; vel &lt;&lt; acc;\n        }\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#logging-with-enumerations","title":"Logging with Enumerations","text":"<pre><code>TEST_F(MyTest, StateLogging) {\n    create_logger(\"States\");\n    get_logger(\"States\") &lt;&lt; \"Time\" &lt;&lt; \"State Name\" &lt;&lt; \"State ID\";\n\n    for (auto state : all_states) {\n        float time = get_simulation_time();\n        std::string name = state.c_str();  // Assumes enum has c_str()\n        int id = static_cast&lt;int&gt;(state);\n\n        get_logger(\"States\") &lt;&lt; time &lt;&lt; name &lt;&lt; id;\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#conditional-logging","title":"Conditional Logging","text":"<pre><code>TEST_F(MyTest, ErrorDetection) {\n    create_logger(\"Errors\");\n    get_logger(\"Errors\") &lt;&lt; \"Time\" &lt;&lt; \"Type\" &lt;&lt; \"Details\";\n\n    simulate_for(1.0f);\n\n    if (error_detected) {\n        get_logger(\"Errors\") \n            &lt;&lt; get_simulation_time() \n            &lt;&lt; \"Timeout\" \n            &lt;&lt; \"No response from controller\";\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#logging-complex-data-structures","title":"Logging Complex Data Structures","text":"<pre><code>TEST_F(MyTest, StructuredData) {\n    create_logger(\"System State\");\n    get_logger(\"System State\") \n        &lt;&lt; \"Time\" \n        &lt;&lt; \"Error Word\" \n        &lt;&lt; \"State\" \n        &lt;&lt; \"Flag1\" \n        &lt;&lt; \"Flag2\" \n        &lt;&lt; \"Flag3\";\n\n    auto data = get_system_data();\n    get_logger(\"System State\")\n        &lt;&lt; get_simulation_time()\n        &lt;&lt; static_cast&lt;uint32_t&gt;(data.error_word)\n        &lt;&lt; data.state.c_str()\n        &lt;&lt; data.flags[0]\n        &lt;&lt; data.flags[1]\n        &lt;&lt; data.flags[2];\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#integration-with-rtos_test","title":"Integration with RTOS_Test","text":"<p>When used with <code>RTOS_Test</code>, loggers can be updated on every simulation step:</p> <pre><code>class MySystemTest : public RTOS_Test {\nprotected:\n    void SetUp() override {\n        Base::SetUp();\n\n        create_logger(\"Continuous Monitor\");\n        get_logger(\"Continuous Monitor\") &lt;&lt; \"Time\" &lt;&lt; \"State\" &lt;&lt; \"Value\";\n\n        // Register periodic logging\n        register_simulation_update([this]() {\n            get_logger(\"Continuous Monitor\")\n                &lt;&lt; get_simulation_time()\n                &lt;&lt; get_current_state().c_str()\n                &lt;&lt; get_monitored_value();\n        });\n    }\n};\n</code></pre>"},{"location":"infrastructure/unit_test/#console-output-examples","title":"Console Output Examples","text":""},{"location":"infrastructure/unit_test/#information-messages","title":"Information Messages","text":"<pre><code>UnitTest::print_info(\"Test starting\");\nUnitTest::print_info(\"Initializing hardware mocks\");\nUnitTest::print_info(\"Simulation complete\");\n</code></pre> <p>Output:</p> <pre><code>[   INFO   ] Test starting\n[   INFO   ] Initializing hardware mocks\n[   INFO   ] Simulation complete\n</code></pre>"},{"location":"infrastructure/unit_test/#error-messages","title":"Error Messages","text":"<pre><code>if (!is_valid_state()) {\n    UnitTest::print_error(\"Invalid state transition detected\");\n}\n\nUnitTest::print_error(\"Timeout waiting for CAN response\");\n</code></pre> <p>Output:</p> <pre><code>[   ERROR   ] Invalid state transition detected\n[   ERROR   ] Timeout waiting for CAN response\n</code></pre>"},{"location":"infrastructure/unit_test/#combined-usage","title":"Combined Usage","text":"<pre><code>TEST_F(MyTest, WithConsoleOutput) {\n    UnitTest::print_info(\"Starting initialization\");\n    initialize_system();\n\n    UnitTest::print_info(\"Running simulation\");\n    simulate_for(1.0f);\n\n    if (errors_detected()) {\n        UnitTest::print_error(\"Errors detected during simulation\");\n        UnitTest::print_error(\"Error count: \" + std::to_string(error_count));\n    } else {\n        UnitTest::print_info(\"Simulation completed successfully\");\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#file-system-behavior","title":"File System Behavior","text":""},{"location":"infrastructure/unit_test/#log-directory-structure","title":"Log Directory Structure","text":"<pre><code>project_root/\n\u251c\u2500\u2500 logs/                           # Created automatically\n\u2502   \u251c\u2500\u2500 TestSuite1_Test1_Logger1.csv\n\u2502   \u251c\u2500\u2500 TestSuite1_Test1_Logger2.csv\n\u2502   \u251c\u2500\u2500 TestSuite1_Test2_Logger1.csv\n\u2502   \u251c\u2500\u2500 TestSuite2_Test1_Logger1.csv\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"infrastructure/unit_test/#directory-creation","title":"Directory Creation","text":"<p>The <code>logs/</code> directory is created automatically on first logger creation:</p> <pre><code>// First call in any test\ncreate_logger(\"Data\");  // Creates logs/ directory if it doesn't exist\n</code></pre>"},{"location":"infrastructure/unit_test/#file-overwriting","title":"File Overwriting","text":"<p>Important: Log files are overwritten on each test run. If you need to preserve logs:</p> <ol> <li>Copy logs directory after test run</li> <li>Rename test to create different files</li> <li>Use version control to track changes</li> </ol>"},{"location":"infrastructure/unit_test/#best-practices","title":"Best Practices","text":""},{"location":"infrastructure/unit_test/#1-create-loggers-in-setup","title":"1. Create Loggers in SetUp","text":"<pre><code>class MyTest : public UnitTest {\nprotected:\n    void SetUp() override {\n        Base::SetUp();\n\n        // Create all loggers needed for this test\n        create_logger(\"Main Data\");\n        create_logger(\"Error Log\");\n\n        // Write headers\n        get_logger(\"Main Data\") &lt;&lt; \"Time\" &lt;&lt; \"Value\";\n        get_logger(\"Error Log\") &lt;&lt; \"Time\" &lt;&lt; \"Error\";\n    }\n};\n</code></pre>"},{"location":"infrastructure/unit_test/#2-use-descriptive-logger-names","title":"2. Use Descriptive Logger Names","text":"<pre><code>// GOOD\ncreate_logger(\"Motor Driver Temperature\");\ncreate_logger(\"CAN Bus Traffic\");\ncreate_logger(\"State Machine Transitions\");\n\n// BAD\ncreate_logger(\"Log1\");\ncreate_logger(\"Data\");\ncreate_logger(\"Output\");\n</code></pre>"},{"location":"infrastructure/unit_test/#3-always-write-headers","title":"3. Always Write Headers","text":"<pre><code>create_logger(\"Data\");\nget_logger(\"Data\") &lt;&lt; \"Time\" &lt;&lt; \"Temperature\" &lt;&lt; \"Pressure\";  // Header\n\n// Then data rows\nget_logger(\"Data\") &lt;&lt; 0.0f &lt;&lt; 20.0f &lt;&lt; 101.3f;\n</code></pre>"},{"location":"infrastructure/unit_test/#4-check-logger-creation-success","title":"4. Check Logger Creation Success","text":"<pre><code>if (!create_logger(\"Data\")) {\n    UnitTest::print_error(\"Logger 'Data' already exists\");\n    FAIL() &lt;&lt; \"Duplicate logger name\";\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#5-use-consistent-data-types","title":"5. Use Consistent Data Types","text":"<pre><code>// GOOD - consistent types per column\nget_logger(\"Data\") &lt;&lt; 0.0f &lt;&lt; 1.5f &lt;&lt; 2.3f;\nget_logger(\"Data\") &lt;&lt; 0.1f &lt;&lt; 1.6f &lt;&lt; 2.4f;\n\n// BAD - mixed types can cause issues\nget_logger(\"Data\") &lt;&lt; 0.0f &lt;&lt; \"text\" &lt;&lt; true;\n</code></pre>"},{"location":"infrastructure/unit_test/#6-log-at-appropriate-frequency","title":"6. Log at Appropriate Frequency","text":"<pre><code>// For high-frequency data, use sampling\nfor (int i = 0; i &lt; 10000; i++) {\n    compute_step();\n\n    // Log every 100th sample\n    if (i % 100 == 0) {\n        get_logger(\"Data\") &lt;&lt; i &lt;&lt; get_value();\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#7-use-console-output-judiciously","title":"7. Use Console Output Judiciously","text":"<pre><code>// GOOD - key milestones\nUnitTest::print_info(\"Initializing to R2D state\");\nsimulate_until_in_state(MSM_States::READY_TO_DRIVE);\nUnitTest::print_info(\"R2D state reached\");\n\n// BAD - too verbose\nfor (int i = 0; i &lt; 1000; i++) {\n    UnitTest::print_info(\"Step \" + std::to_string(i));  // Clutters output\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#8-flush-important-data","title":"8. Flush Important Data","text":"<p>The logger automatically flushes after each line, ensuring data is written even if the test crashes:</p> <pre><code>// Each call to get_logger() creates a LoggerProxy that\n// flushes in its destructor\nget_logger(\"Critical\") &lt;&lt; time &lt;&lt; important_value;  // Auto-flushed\n</code></pre>"},{"location":"infrastructure/unit_test/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"infrastructure/unit_test/#1-forgetting-to-create-logger","title":"1. Forgetting to Create Logger","text":"<pre><code>// WRONG - will assert/crash\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f;  // Logger \"Data\" doesn't exist!\n\n// CORRECT\ncreate_logger(\"Data\");\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f;\n</code></pre>"},{"location":"infrastructure/unit_test/#2-creating-logger-multiple-times","title":"2. Creating Logger Multiple Times","text":"<pre><code>// WRONG\nfor (int i = 0; i &lt; 10; i++) {\n    create_logger(\"Data\");  // Only first call succeeds\n    get_logger(\"Data\") &lt;&lt; i;\n}\n\n// CORRECT\ncreate_logger(\"Data\");\nfor (int i = 0; i &lt; 10; i++) {\n    get_logger(\"Data\") &lt;&lt; i;\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#3-not-writing-headers","title":"3. Not Writing Headers","text":"<pre><code>// WRONG - CSV without headers is hard to interpret\ncreate_logger(\"Data\");\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f &lt;&lt; 3.0f;\n\n// CORRECT\ncreate_logger(\"Data\");\nget_logger(\"Data\") &lt;&lt; \"Time\" &lt;&lt; \"Temp\" &lt;&lt; \"Pressure\";\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f &lt;&lt; 3.0f;\n</code></pre>"},{"location":"infrastructure/unit_test/#4-incorrect-data-alignment","title":"4. Incorrect Data Alignment","text":"<pre><code>// WRONG - mismatched column count\nget_logger(\"Data\") &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";  // 3 columns\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f;        // 2 values!\n\n// CORRECT\nget_logger(\"Data\") &lt;&lt; \"A\" &lt;&lt; \"B\" &lt;&lt; \"C\";\nget_logger(\"Data\") &lt;&lt; 1.0f &lt;&lt; 2.0f &lt;&lt; 3.0f;\n</code></pre>"},{"location":"infrastructure/unit_test/#5-not-calling-base-teardown","title":"5. Not Calling Base TearDown","text":"<pre><code>// WRONG - loggers won't be cleaned up\nvoid TearDown() override {\n    my_cleanup();\n    // Missing Base::TearDown()!\n}\n\n// CORRECT\nvoid TearDown() override {\n    my_cleanup();\n    Base::TearDown();\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#advanced-usage","title":"Advanced Usage","text":""},{"location":"infrastructure/unit_test/#custom-logger-formatting","title":"Custom Logger Formatting","text":"<p>While the logger uses CSV format by default, you can work around this:</p> <pre><code>// For complex formatting, consider writing to both logger and console\nget_logger(\"Data\") &lt;&lt; time &lt;&lt; value;\nUnitTest::print_info(\"At t=\" + std::to_string(time) + \", value=\" + std::to_string(value));\n</code></pre>"},{"location":"infrastructure/unit_test/#conditional-logger-creation","title":"Conditional Logger Creation","text":"<pre><code>TEST_F(MyTest, ConditionalLogging) {\n    bool enable_detailed_logging = should_enable_detailed_logging();\n\n    if (enable_detailed_logging) {\n        create_logger(\"Detailed\");\n        get_logger(\"Detailed\") &lt;&lt; \"Time\" &lt;&lt; \"Detail1\" &lt;&lt; \"Detail2\";\n    }\n\n    // Later, check before using\n    if (enable_detailed_logging) {\n        get_logger(\"Detailed\") &lt;&lt; time &lt;&lt; detail1 &lt;&lt; detail2;\n    }\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#dynamic-logger-names","title":"Dynamic Logger Names","text":"<pre><code>TEST_F(MyTest, DynamicLoggers) {\n    std::vector&lt;std::string&gt; sensors = {\"Temp\", \"Press\", \"Flow\"};\n\n    for (const auto&amp; sensor : sensors) {\n        create_logger(sensor + \" Data\");\n        get_logger(sensor + \" Data\") &lt;&lt; \"Time\" &lt;&lt; \"Value\";\n    }\n\n    // Log to appropriate logger\n    get_logger(\"Temp Data\") &lt;&lt; 1.0f &lt;&lt; 25.5f;\n    get_logger(\"Press Data\") &lt;&lt; 1.0f &lt;&lt; 101.3f;\n}\n</code></pre>"},{"location":"infrastructure/unit_test/#limitations","title":"Limitations","text":"<ol> <li>CSV Format Only: Loggers output CSV format only</li> <li>No Custom Delimiters: Comma is the only delimiter</li> <li>No Binary Logging: All data is text-based</li> <li>No Log Rotation: Files are overwritten on each test run</li> <li>No Runtime Log Level: All created loggers are active</li> </ol>"},{"location":"infrastructure/unit_test/#see-also","title":"See Also","text":"<ul> <li>RTOS_Test - Integration test base class using UnitTest</li> <li>MCS_Back_Test - Specialized test class with logging examples</li> <li>Google Test documentation for assertion and test structure</li> <li>CSV file format specification for data analysis tools</li> </ul>"},{"location":"library/torque_map/","title":"Torque Map","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/architecture/","title":"MCS_Back - Architecture","text":""},{"location":"mcs_back/architecture/#high-level-system-design","title":"High Level System Design","text":""},{"location":"mcs_back/architecture/#high-level-data-flow","title":"High Level Data Flow","text":""},{"location":"mcs_back/architecture/#first-tier-tasks","title":"First tier tasks","text":""},{"location":"mcs_back/architecture/#synchronization-and-data-flow","title":"Synchronization and data flow","text":""},{"location":"mcs_back/architecture/#tasks","title":"Tasks","text":""},{"location":"mcs_back/architecture/#process-inputs","title":"Process Inputs","text":"<p>Process Inputs task takes care of processing sensors measurements and digital input states to a meaningful data or events, that are then used by the Application. Processed analog and speed measurements are stored in the Process data store. This structure is protected by a mutex. This mutex can be taken either by this task or Application. Application should be informed when new data has been written to this structure. This information should be passed via a queue. Events that are generated based on button (digital input) states, are also passed to Application via a queue.</p>"},{"location":"mcs_back/architecture/#analog-sensors","title":"Analog sensors","text":"<p>Each time the DMA finishes full ADC reading cycle, it should enqueue new data to the Process Inputs queue.</p>"},{"location":"mcs_back/architecture/#pwm-signals","title":"PWM signals","text":"<p>Wheel speed sensors are the only sources of PWM signals. Based on the rising and falling edges of these signals, the actual wheel speed should be calculated inside the interrupt routine and then enqueued to Process Inputs. Process Inputs should monitor when he received the last speed measurement. If there's no new update of speed for some precalculated, realistic time, the value of speed measurement stored in Process data store should be set to 0.</p>"},{"location":"mcs_back/architecture/#network-manager","title":"Network Manager","text":"<p>Network Manager is common between different MechPower created boards. Further information about this task can be found on Network Manger page.</p>"},{"location":"mcs_back/architecture/#application","title":"Application","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/architecture/#sd-card-control","title":"SD Card Control","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/architecture/#water-pump","title":"Water Pump","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/architecture/#r2d-buzzer-control","title":"R2D Buzzer Control","text":"<p>Warning</p> <p>TODO</p>"},{"location":"mcs_back/mcs_back_test/","title":"MCS_Back_Test Class","text":""},{"location":"mcs_back/mcs_back_test/#overview","title":"Overview","text":"<p><code>MCS_Back_Test</code> is a specialized integration test class for the MCS_Back (Motor Control System - Back) board. It extends <code>RTOS_Test</code> with board-specific functionality including GPIO mocking, ADC simulation, motor driver interfaces, and state machine testing capabilities.</p>"},{"location":"mcs_back/mcs_back_test/#location","title":"Location","text":"<pre><code>software/tests/_test_helpers/mcs_back_test.h\nsoftware/tests/_test_helpers/mcs_back_test.cpp\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#class-hierarchy","title":"Class Hierarchy","text":"<pre><code>::testing::Test\n    \u2514\u2500\u2500 UnitTest\n        \u2514\u2500\u2500 RTOS_Test\n            \u2514\u2500\u2500 MCS_Back_Test\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#key-features","title":"Key Features","text":"<ul> <li> <p>State Machine Testing: Direct access to MSM states and status flags</p> </li> <li> <p>GPIO Simulation: Mock GPIO interfaces for all board signals</p> </li> <li> <p>ADC Input Control: Set and verify analog input values</p> </li> <li> <p>Motor Driver Permits: Monitor and test RFE/FRG permit signals</p> </li> <li> <p>Application Data Access: Thread-safe reading of application state</p> </li> <li> <p>State Initialization: Helper methods to quickly reach specific FSM states</p> </li> <li> <p>Periodic ADC Updates: Automatic ADC interrupt generation</p> </li> </ul>"},{"location":"mcs_back/mcs_back_test/#type-aliases","title":"Type Aliases","text":"<pre><code>using MSM_Status = Operation::MCS_Back::MSM::MSM_Status;\nusing MSM_Status_Flags = Operation::MCS_Back::MSM_Status_Flags;\nusing MSM_States = Operation::MCS_Back::MSM_States;\nusing App_Data = Operation::MCS_Back::Application::Data;\nusing Shared_Data = Operation::MCS_Back::Application_Task_Data;\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#enumerations","title":"Enumerations","text":""},{"location":"mcs_back/mcs_back_test/#gpio-pins","title":"GPIO Pins","text":"<pre><code>enum class GPIOs {\n    R2D_SOUND,              // Ready-to-drive buzzer\n    SDC_STATUS,             // Shutdown circuit status\n    MD_L_RFE_PERMIT,        // Left motor driver - Rotating Field Enable\n    MD_R_RFE_PERMIT,        // Right motor driver - Rotating Field Enable\n    MD_L_FRG_PERMIT,        // Left motor driver - Field Release Gate\n    MD_R_FRG_PERMIT,        // Right motor driver - Field Release Gate\n    BRAKE_LAMP,             // Brake light control\n    LAST\n};\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#adc-inputs","title":"ADC Inputs","text":"<pre><code>enum class ADC_Inputs {\n    POWER_SUPPLY_VOLTAGE,   // 12V power supply monitoring\n    BRAKE_LAMP_CURRENT,     // Brake lamp current sensing\n    LAST\n};\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#setup-and-teardown","title":"Setup and Teardown","text":""},{"location":"mcs_back/mcs_back_test/#constructor","title":"Constructor","text":"<pre><code>MCS_Back_Test();\n</code></pre> <p>Initializes the test with MCS_Back board configuration and sets up ADC periodic hook.</p>"},{"location":"mcs_back/mcs_back_test/#setup","title":"SetUp()","text":"<pre><code>virtual void SetUp() override;\n</code></pre> <p>Performs comprehensive initialization:</p> <ol> <li> <p>Creates network manager buffers and tasks</p> </li> <li> <p>Sets up process inputs task with ADC and wheel speed queues</p> </li> <li> <p>Configures water pump task</p> </li> <li> <p>Creates application task</p> </li> <li> <p>Registers ADC DMA interrupt handler</p> </li> <li> <p>Sets initial power supply voltage (12.0V)</p> </li> <li> <p>Triggers initial ADC conversion</p> </li> </ol> <p>Important: Always call after any derived class setup: <pre><code>void SetUp() override {\n    Base::SetUp();\n    // Your additional setup\n}\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#teardown","title":"TearDown()","text":"<pre><code>virtual void TearDown() override;\n</code></pre> <p>Prints error word value in debug builds and calls base teardown.</p>"},{"location":"mcs_back/mcs_back_test/#core-methods","title":"Core Methods","text":""},{"location":"mcs_back/mcs_back_test/#gpio-access","title":"GPIO Access","text":""},{"location":"mcs_back/mcs_back_test/#get_gpio","title":"get_gpio()","text":"<pre><code>Firmware::GPIO_Interface&amp; get_gpio(GPIOs gpio);\n</code></pre> <p>Returns a reference to the specified GPIO mock.</p> <p>Example: <pre><code>// Check if RFE permit is active\nbool rfe_active = get_gpio(GPIOs::MD_L_RFE_PERMIT).read();\n\n// Activate brake lamp\nget_gpio(GPIOs::BRAKE_LAMP).write(true);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#application-state-access","title":"Application State Access","text":""},{"location":"mcs_back/mcs_back_test/#get_app_data","title":"get_app_data()","text":"<pre><code>App_Data const get_app_data();\n</code></pre> <p>Returns a copy of the current application data. Thread-safe.</p> <p>Available fields: <pre><code>struct App_Data {\n    bool precharge_status_from_tsac;\n    Real accelerator_pedal_position;\n    Real brake_pedal_position;\n    Real steering_wheel_angle;\n    Real front_left_speed_rpm;\n    Real front_right_speed_rpm;\n    Library::Torque_Controller::Output torque_controller_output;\n    Library::Brake_Lamp_Control_And_Monitoring::Output brake_lamp;\n    Library::Power_Supply_Monitoring::Output power_supply;\n    SI::Temperature md_l_temperature;\n    SI::Temperature md_r_temperature;\n    SI::Temperature max_temperature;\n    Error_Word error_word;\n};\n</code></pre></p> <p>Example: <pre><code>auto data = get_app_data();\nEXPECT_FLOAT_EQ(data.accelerator_pedal_position, 50.0f);\nEXPECT_TRUE(data.brake_lamp.is_braking);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#get_shared_data","title":"get_shared_data()","text":"<pre><code>Shared_Data const get_shared_data();\n</code></pre> <p>Returns a copy of data shared between tasks. Thread-safe.</p> <p>Available fields: <pre><code>struct Shared_Data {\n    float brake_lamp_current;\n    float power_supply_voltage;\n    float r_rear_wheel_speed_rpm;\n    float l_rear_wheel_speed_rpm;\n    bool sdc_status;\n};\n</code></pre></p> <p>Example: <pre><code>auto shared = get_shared_data();\nEXPECT_GT(shared.power_supply_voltage, 11.0f);\nEXPECT_LT(shared.brake_lamp_current, 2.0f);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#state-machine-access","title":"State Machine Access","text":""},{"location":"mcs_back/mcs_back_test/#get_status_flags","title":"get_status_flags()","text":"<pre><code>MSM_Status const get_status_flags();\n</code></pre> <p>Returns all state machine status flags.</p> <p>Available flags: <pre><code>enum class MSM_Status_Flags {\n    is_ts_ready_for_activation,\n    is_ts_active,\n    are_air_permits_granted,\n    are_rfe_permits_granted,\n    are_frg_permits_granted,\n    has_frg_permit_elapsed,\n    is_initialized,\n    is_torque_controller_enabled,\n    is_ready_to_drive,\n    is_precharged,\n    is_error_free,\n    is_water_cooling_enabled\n};\n</code></pre></p> <p>Example: <pre><code>auto status = get_status_flags();\nEXPECT_TRUE(status[MSM_Status_Flags::is_initialized]);\nEXPECT_FALSE(status[MSM_Status_Flags::is_ready_to_drive]);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#get_status_flag","title":"get_status_flag()","text":"<pre><code>bool const get_status_flag(Operation::MCS_Back::MSM_Status_Flags status_flag);\n</code></pre> <p>Returns a single status flag value.</p> <p>Example: <pre><code>bool is_r2d = get_status_flag(MSM_Status_Flags::is_ready_to_drive);\nEXPECT_TRUE(is_r2d);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#get_current_state","title":"get_current_state()","text":"<pre><code>MSM_States const get_current_state();\n</code></pre> <p>Returns the current state machine state.</p> <p>Available states:</p> <ul> <li> <p><code>MSM_States::INIT</code> - Initialization</p> </li> <li> <p><code>MSM_States::TS_READY_FOR_ACTIVATION</code> - Tractive System Ready</p> </li> <li> <p><code>MSM_States::PRE_CHARGE</code> - Pre-charging</p> </li> <li> <p><code>MSM_States::ROTATING_FIELD_ENABLED</code> - Motors energized</p> </li> <li> <p><code>MSM_States::READY_TO_DRIVE</code> - Ready to drive</p> </li> <li> <p><code>MSM_States::FAULTY</code> - Error state</p> </li> </ul> <p>Example: <pre><code>auto state = get_current_state();\nEXPECT_EQ(state, MSM_States::READY_TO_DRIVE);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#is_in_state","title":"is_in_state()","text":"<pre><code>bool is_in_state(MSM_States state, bool silent = true);\n</code></pre> <p>Checks if the state machine is in the specified state.</p> <p>Parameters:</p> <ul> <li> <p><code>state</code>: Expected state</p> </li> <li> <p><code>silent</code>: If <code>false</code>, prints error message on mismatch</p> </li> </ul> <p>Example: <pre><code>// Silent check\nif (is_in_state(MSM_States::READY_TO_DRIVE)) {\n    // Proceed with R2D test\n}\n\n// With error output\nEXPECT_TRUE(is_in_state(MSM_States::READY_TO_DRIVE, false));\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#state-machine-simulation","title":"State Machine Simulation","text":""},{"location":"mcs_back/mcs_back_test/#simulate_until_in_state","title":"simulate_until_in_state()","text":"<pre><code>void simulate_until_in_state(MSM_States state, SI::Time timeout = 1.0f);\n</code></pre> <p>Simulates until the specified state is reached or timeout occurs. Asserts if timeout.</p> <p>Parameters:</p> <ul> <li> <p><code>state</code>: Target state</p> </li> <li> <p><code>timeout</code>: Maximum wait time (default: 1.0s)</p> </li> </ul> <p>Example: <pre><code>// Wait for initialization\nsimulate_until_in_state(MSM_States::TS_READY_FOR_ACTIVATION);\n\n// With custom timeout\nsimulate_until_in_state(MSM_States::READY_TO_DRIVE, 2.0f);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#initialize_to_state","title":"initialize_to_state()","text":"<pre><code>void initialize_to_state(MSM_States state, bool is_prerequisite = false);\n</code></pre> <p>Performs all necessary steps to reach a specific state, including sending required CAN messages and waiting for conditions.</p> <p>Parameters:</p> <ul> <li> <p><code>state</code>: Target state</p> </li> <li> <p><code>is_prerequisite</code>: If <code>true</code>, suppresses \"Initialized to\" message (for chained initialization)</p> </li> </ul> <p>Supported States:</p> <ul> <li> <p><code>INIT</code> - Does nothing (initial state)</p> </li> <li> <p><code>TS_READY_FOR_ACTIVATION</code> - Waits for initialization</p> </li> <li> <p><code>PRE_CHARGE</code> - Sends TS activation request</p> </li> <li> <p><code>ROTATING_FIELD_ENABLED</code> - Sends precharge complete message</p> </li> <li> <p><code>READY_TO_DRIVE</code> - Waits for FRG permit delay and sends R2D activation</p> </li> <li> <p><code>FAULTY</code> - Not yet implemented</p> </li> </ul> <p>Example: <pre><code>// Initialize to R2D state\ninitialize_to_state(MSM_States::READY_TO_DRIVE);\n\n// Now in R2D, can test R2D-specific behavior\nEXPECT_TRUE(get_gpio(GPIOs::MD_L_FRG_PERMIT).read());\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#adc-simulation","title":"ADC Simulation","text":""},{"location":"mcs_back/mcs_back_test/#set_adc_input","title":"set_adc_input()","text":"<pre><code>void set_adc_input(ADC_Inputs input, uint32_t value);\n</code></pre> <p>Sets the raw ADC value for a specific input. The value should be a 12-bit ADC reading (0-4095).</p> <p>Helper Functions (in <code>adc_mock.h</code>): <pre><code>// Convert real current to ADC reading\nuint32_t Simulator::helpers::current_to_reading(float actual_current);\n\n// Convert real voltage to ADC reading\nuint32_t Simulator::helpers::voltage_to_reading(float actual_voltage);\n</code></pre></p> <p>Example: <pre><code>// Set power supply voltage to 12.5V\nSI::Voltage voltage = 12.5f;\nset_adc_input(\n    ADC_Inputs::POWER_SUPPLY_VOLTAGE,\n    Simulator::helpers::voltage_to_reading(voltage)\n);\n\n// Set brake lamp current to 0.5A\nSI::Current current = 0.5f;\nset_adc_input(\n    ADC_Inputs::BRAKE_LAMP_CURRENT,\n    Simulator::helpers::current_to_reading(current)\n);\n\n// Wait for ADC conversion\nsimulate_for(0.01f);\n\n// Verify\nauto data = get_shared_data();\nEXPECT_NEAR(data.power_supply_voltage, 12.5f, 0.1f);\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#usage-patterns","title":"Usage Patterns","text":""},{"location":"mcs_back/mcs_back_test/#basic-state-machine-test","title":"Basic State Machine Test","text":"<pre><code>TEST_F(MCS_Back_Test, EntersReadyToDrive) {\n    // Initialize to R2D state\n    initialize_to_state(MSM_States::READY_TO_DRIVE);\n\n    // Verify state and flags\n    EXPECT_TRUE(is_in_state(MSM_States::READY_TO_DRIVE));\n    EXPECT_TRUE(get_status_flag(MSM_Status_Flags::is_ready_to_drive));\n    EXPECT_TRUE(get_status_flag(MSM_Status_Flags::are_frg_permits_granted));\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#testing-gpio-outputs","title":"Testing GPIO Outputs","text":"<pre><code>TEST_F(MCS_Back_Test, MotorDriverPermits) {\n    initialize_to_state(MSM_States::ROTATING_FIELD_ENABLED);\n\n    // Check RFE permits are active\n    EXPECT_TRUE(get_gpio(GPIOs::MD_L_RFE_PERMIT).read());\n    EXPECT_TRUE(get_gpio(GPIOs::MD_R_RFE_PERMIT).read());\n\n    // FRG permits should not be active yet\n    EXPECT_FALSE(get_gpio(GPIOs::MD_L_FRG_PERMIT).read());\n    EXPECT_FALSE(get_gpio(GPIOs::MD_R_FRG_PERMIT).read());\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#testing-adc-inputs","title":"Testing ADC Inputs","text":"<pre><code>TEST_F(MCS_Back_Test, UndervoltageDetection) {\n    initialize_to_state(MSM_States::TS_READY_FOR_ACTIVATION);\n\n    // Set undervoltage\n    SI::Voltage undervoltage = 10.0f;\n    set_adc_input(\n        ADC_Inputs::POWER_SUPPLY_VOLTAGE,\n        Simulator::helpers::voltage_to_reading(undervoltage)\n    );\n\n    // Wait for detection (20ms delay + margin)\n    simulate_for(0.05f);\n\n    // Should enter fault state\n    EXPECT_TRUE(is_in_state(MSM_States::FAULTY));\n    EXPECT_FALSE(get_status_flag(MSM_Status_Flags::is_error_free));\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#testing-can-communication","title":"Testing CAN Communication","text":"<pre><code>TEST_F(MCS_Back_Test, ReceivesPedalPositions) {\n    simulate_for(0.1f);\n\n    // Send pedal positions from front\n    Real apps = 50.0f, bpps = 10.0f, swa = 90.0f;\n    Front_Analog_Sensors_Msg msg{apps, bpps, swa};\n    auto frame = CAN_Message_Traits&lt;Front_Analog_Sensors_Msg&gt;::encode(msg);\n    receive_CAN_message(Operation::CAN_Instance::CAN_1, frame);\n\n    // Wait for processing\n    simulate_for(0.02f);\n\n    // Verify reception\n    auto data = get_app_data();\n    EXPECT_NEAR(data.accelerator_pedal_position, apps, 0.5f);\n    EXPECT_NEAR(data.brake_pedal_position, bpps, 0.5f);\n    EXPECT_NEAR(data.steering_wheel_angle, swa, 0.5f);\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#testing-state-transitions","title":"Testing State Transitions","text":"<pre><code>TEST_F(MCS_Back_Test, TransitionsOnDeactivation) {\n    initialize_to_state(MSM_States::PRE_CHARGE);\n\n    // Send TS deactivation\n    TS_Activate_Msg msg{false};\n    auto frame = CAN_Message_Traits&lt;TS_Activate_Msg&gt;::encode(msg);\n    receive_CAN_message(Operation::CAN_Instance::CAN_1, frame);\n\n    // Should transition to TS_READY\n    simulate_until_in_state(MSM_States::TS_READY_FOR_ACTIVATION);\n\n    // Verify permits are removed\n    EXPECT_FALSE(get_status_flag(MSM_Status_Flags::are_air_permits_granted));\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#parameterized-state-tests","title":"Parameterized State Tests","text":"<pre><code>class PermitsTest : public MCS_Back_Test, \n                    public ::testing::WithParamInterface&lt;MSM_States&gt; {\n};\n\nINSTANTIATE_TEST_SUITE_P(\n    , PermitsTest,\n    ::testing::Values(\n        MSM_States::INIT,\n        MSM_States::TS_READY_FOR_ACTIVATION,\n        MSM_States::PRE_CHARGE,\n        MSM_States::ROTATING_FIELD_ENABLED,\n        MSM_States::READY_TO_DRIVE\n    )\n);\n\nTEST_P(PermitsTest, CorrectPermitStates) {\n    auto target_state = GetParam();\n    initialize_to_state(target_state);\n\n    switch (target_state) {\n    case MSM_States::READY_TO_DRIVE:\n        EXPECT_TRUE(get_gpio(GPIOs::MD_L_RFE_PERMIT).read());\n        EXPECT_TRUE(get_gpio(GPIOs::MD_L_FRG_PERMIT).read());\n        break;\n    case MSM_States::ROTATING_FIELD_ENABLED:\n        EXPECT_TRUE(get_gpio(GPIOs::MD_L_RFE_PERMIT).read());\n        EXPECT_FALSE(get_gpio(GPIOs::MD_L_FRG_PERMIT).read());\n        break;\n    default:\n        EXPECT_FALSE(get_gpio(GPIOs::MD_L_RFE_PERMIT).read());\n        EXPECT_FALSE(get_gpio(GPIOs::MD_L_FRG_PERMIT).read());\n        break;\n    }\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#testing-with-logging","title":"Testing with Logging","text":"<pre><code>TEST_F(MCS_Back_Test, MonitorsVoltageOverTime) {\n    create_logger(\"Voltage Monitor\");\n    get_logger(\"Voltage Monitor\") &lt;&lt; \"Time\" &lt;&lt; \"Voltage\" &lt;&lt; \"Error Free\";\n\n    register_simulation_update([this]() {\n        auto data = get_shared_data();\n        bool error_free = get_status_flag(MSM_Status_Flags::is_error_free);\n        get_logger(\"Voltage Monitor\") \n            &lt;&lt; get_simulation_time() \n            &lt;&lt; data.power_supply_voltage \n            &lt;&lt; error_free;\n    });\n\n    // Run test with varying voltage\n    for (float v = 11.0f; v &lt;= 14.0f; v += 0.5f) {\n        set_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, \n                     Simulator::helpers::voltage_to_reading(v));\n        simulate_for(0.1f);\n    }\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#important-notes","title":"Important Notes","text":""},{"location":"mcs_back/mcs_back_test/#thread-safety","title":"Thread Safety","text":"<p>Application and shared data access is thread-safe through mutex protection: <pre><code>// Safe - returns a copy\nauto data = get_app_data();\nauto shared = get_shared_data();\n\n// Not safe - don't try to access internal structures directly\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#adc-periodic-updates","title":"ADC Periodic Updates","text":"<p>ADC conversions are triggered automatically every 1ms via a periodic hook registered during <code>SetUp()</code>. Manual triggering is also possible:</p> <pre><code>set_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, value);\ntrigger_isr(Simulator::Interrupt_Vector::MCS_BACK_ADC_DMA);  // Manual trigger\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#state-initialization-overhead","title":"State Initialization Overhead","text":"<p><code>initialize_to_state()</code> performs real initialization including:</p> <ul> <li> <p>Waiting for delays (e.g., 600ms FRG permit delay for R2D)</p> </li> <li> <p>Sending required CAN messages</p> </li> <li> <p>Verifying state transitions</p> </li> </ul> <p>This means tests may take significant time when initializing to higher states.</p>"},{"location":"mcs_back/mcs_back_test/#error-word","title":"Error Word","text":"<p>The error word is a 32-bit field with individual bits for each error:</p> <pre><code>enum class Error_Word_Bits {\n    HANDSHAKE_NOT_ACKNOWLEDGED,\n    R2D_TIMER_FAILURE_TO_START,\n    UNDERVOLTAGE,\n    NETWORK_MANAGER_TX_BUFFER_FULL,\n    BRAKE_LAMP_OVERCURRENT,\n    BRAKE_LAMP_OPEN_CIRCUIT,\n    WATER_PUMP_TX_QUEUE_FULL,\n    POWER_SUPPLY_OVERVOLTAGE,\n    POWER_SUPPLY_UNDERVOLTAGE,\n    LAST,\n};\n</code></pre> <p>Check specific errors: <pre><code>auto data = get_app_data();\nbool has_undervoltage = data.error_word &amp; (1 &lt;&lt; static_cast&lt;uint32_t&gt;(Error_Word_Bits::UNDERVOLTAGE));\n</code></pre></p>"},{"location":"mcs_back/mcs_back_test/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always initialize to the required state <pre><code>// GOOD\ninitialize_to_state(MSM_States::READY_TO_DRIVE);\n// Test R2D-specific behavior\n\n// BAD\n// Manually try to replicate initialization\n</code></pre></p> </li> <li> <p>Use condition-based waiting for state transitions <pre><code>// GOOD\nsimulate_until_in_state(MSM_States::READY_TO_DRIVE);\n\n// BAD\nsimulate_for(1.0f);  // May be too short or too long\n</code></pre></p> </li> <li> <p>Use helper functions for ADC values <pre><code>// GOOD\nset_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, \n              Simulator::helpers::voltage_to_reading(12.0f));\n\n// BAD\nset_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, 2048);  // What does this mean?\n</code></pre></p> </li> <li> <p>Check both state and status flags <pre><code>EXPECT_TRUE(is_in_state(MSM_States::READY_TO_DRIVE));\nEXPECT_TRUE(get_status_flag(MSM_Status_Flags::is_ready_to_drive));\nEXPECT_TRUE(get_status_flag(MSM_Status_Flags::are_frg_permits_granted));\n</code></pre></p> </li> <li> <p>Allow time for processing <pre><code>// Send CAN message\nreceive_CAN_message(CAN_Instance::CAN_1, frame);\n\n// Give time to process (at least 10ms for task cycle)\nsimulate_for(0.02f);\n\n// Now check results\n</code></pre></p> </li> </ol>"},{"location":"mcs_back/mcs_back_test/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"mcs_back/mcs_back_test/#not-waiting-after-adc-updates","title":"Not Waiting After ADC Updates","text":"<pre><code>// WRONG\nset_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, value);\nauto data = get_shared_data();  // Old value!\n\n// CORRECT\nset_adc_input(ADC_Inputs::POWER_SUPPLY_VOLTAGE, value);\nsimulate_for(0.01f);  // Wait for processing\nauto data = get_shared_data();  // New value\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#forgetting-delay-requirements","title":"Forgetting Delay Requirements","text":"<pre><code>// The FRG permit has a 600ms delay\ninitialize_to_state(MSM_States::ROTATING_FIELD_ENABLED);\nEXPECT_FALSE(get_status_flag(MSM_Status_Flags::has_frg_permit_elapsed));\n\n// Must wait for delay\nsimulate_for(0.65f);\nEXPECT_TRUE(get_status_flag(MSM_Status_Flags::has_frg_permit_elapsed));\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#ignoring-silent-parameter","title":"Ignoring Silent Parameter","text":"<pre><code>// Debug output enabled\nEXPECT_TRUE(is_in_state(MSM_States::READY_TO_DRIVE, false));\n\n// Silent check for conditional logic\nif (is_in_state(MSM_States::READY_TO_DRIVE)) {\n    // Do something\n}\n</code></pre>"},{"location":"mcs_back/mcs_back_test/#see-also","title":"See Also","text":"<ul> <li> <p>RTOS_Test - Base class documentation</p> </li> <li> <p>State machine documentation</p> </li> <li> <p>Integration tests in <code>software/tests/integration_tests/mcs_back/</code></p> </li> </ul>"},{"location":"mcs_back/state_machine/","title":"State Machine","text":""},{"location":"mcs_back/state_machine/#diagram","title":"Diagram","text":"<pre>c3eaafa6ca5c2c67b793ee90367a5954204dd3c1f4172a06e55ec13eb48b50e5a57b56846719269d97e56a3706bf5317cb71d726cc729657030f4b2717fded4c</pre><pre>544bd25eec834abe5105221c5cda45b288a54757c9b7fc98220b594d2d79e46b3c8a306fe9076811d5516d87baa6fdb26eb002a8d18028a0e0d3d1b6f0b37604</pre>"},{"location":"mcs_front/architecture/","title":"MCS_Front - Architecture","text":""},{"location":"mcs_front/architecture/#high-level-system-design","title":"High Level System Design","text":""},{"location":"mcs_front/architecture/#high-level-data-flow","title":"High Level Data Flow","text":""},{"location":"mcs_front/architecture/#first-tier-tasks","title":"First tier tasks","text":""},{"location":"mcs_front/architecture/#synchronization-and-data-flow","title":"Synchronization and data flow","text":""},{"location":"mcs_front/architecture/#tasks","title":"Tasks","text":""},{"location":"mcs_front/architecture/#process-inputs","title":"Process Inputs","text":"<p>Process Inputs task takes care of processing sensors measurements and digital input states to a meaningful data or events, that are then used by the Application. Processed analog and speed measurements are stored in the Process data store. This structure is protected by a mutex. This mutex can be taken either by this task or Application. Application should be informed when new data has been written to this structure. This information should be passed via a queue. Events that are generated based on button (digital input) states, are also passed to Application via a queue.</p>"},{"location":"mcs_front/architecture/#analog-sensors","title":"Analog sensors","text":"<p>Each time the DMA finishes full ADC reading cycle, it should enqueue new data to the Process Inputs queue.</p>"},{"location":"mcs_front/architecture/#pwm-signals","title":"PWM signals","text":"<p>Wheel speed sensors are the only sources of PWM signals. Based on the rising and falling edges of these signals, the actual wheel speed should be calculated inside the interrupt routine and then enqueued to Process Inputs. Process Inputs should monitor when he received the last speed measurement. If there's no new update of speed for some precalculated, realistic time, the value of speed measurement stored in Process data store should be set to 0.</p>"},{"location":"mcs_front/architecture/#process-buttons","title":"Process Buttons","text":"<p>Digital inputs should be periodically read by the Process Buttons. This task should implement software debouncing, so the button needs to be pushed or released continuously for a predefined period of time for the transition to be detected. If the transition is detected, an event about such transition should be enqueued to Application. For some buttons, e.g. R2D there should be an additional long press detection implemented, so that if the button is pressed for a long (predefined) period of time, additional event is enqueued for the Application informing about it. It will be needed so to prevent driver from mistakenly pushing the button and leaving the R2D mode during the race.</p>"},{"location":"mcs_front/architecture/#network-manager","title":"Network Manager","text":"<p>Network Manager is common between different MechPower created boards. Further information about this task can be found on Network Manger page.</p>"},{"location":"mcs_front/architecture/#application","title":"Application","text":"<p>Application Task performs mainly two functions. It runs the state machine and analyzes faults coming from the Network Manager.</p>"},{"location":"mcs_front/architecture/#handling-faults","title":"Handling faults","text":"<p>Statuses of different car elements are interpreted by the Fault Interpreter block indicated on the diagram. It stores the current state (faulty or fault free) of: motors, motor drivers, insulation monitoring device, accumulator management system and other internal signals. If any of these states change, a corresponding flag is raised and sent to the Indicators Control task.</p> <p>Also, when there are any faults present, they are sorted by their severity. The most severe one is sent to the state machine, which can then prevent driver from entering the TS activated or R2D modes. It's also sent to the UI, to be presented for the driver.</p>"},{"location":"mcs_front/architecture/#ui","title":"UI","text":"<p>Warning</p> <p>TODO</p> <p>UI task should interpret messages enqueued to it. These message can either change screens or data displayed on these screens. It should act as a gateway to the TouchGFX generated code/task.</p>"},{"location":"mcs_front/architecture/#indicators-control","title":"Indicators Control","text":"<p>Indicators Control Task continuously reads the queue, listening for fault events. These events can either set or clear faults, which are then displayed to the driver via LED indicators.</p>"},{"location":"mcs_front/state_machine/","title":"Display State Machine","text":"<p>Warning</p> <p>Outdated</p> <p>Display state machine (SM) consists of one main SM and few inner ones.</p>"},{"location":"mcs_front/state_machine/#main-sm","title":"Main SM","text":"<p>Main SM states are:</p> <ul> <li>Initialization,</li> <li>Idle,</li> <li>R2D.</li> </ul> <p>Initialization is a state during which the calibration process happens.</p> <p>Idle is a state, when device awaits inputs from the driver. Driver can then change settings of the car, and try to grant permissions for TS activation.</p> <p>R2D is the Ready2Drive state. Driver can't change any previously set settings of the car. The car is ready for a race.</p>"},{"location":"mcs_front/state_machine/#calibration","title":"Calibration","text":""},{"location":"mcs_front/state_machine/#settings","title":"Settings","text":""},{"location":"mcs_front/state_machine/#r2d","title":"R2D","text":"<pre>b7ac538ecf0fdce357cbc96b7755d7a5514815ad2b758a32526f0b7e3048e29ad35c2b2268a6958e79ccd0768d066b26ecb2c12d0319aa3a81a53f6f0b2dde55</pre><pre>b141fddeed2532dabc85d14982f7e56a64e2af75bcb005d946f20472aab6724e88fb0a700b7066aec296a4a492a47b64a0c4a65a4f0b05269f651a333d77cc34</pre>"}]}